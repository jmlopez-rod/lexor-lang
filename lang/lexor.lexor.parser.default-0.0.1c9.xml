<module name="main">
    <doc>
        <![CDATA[LEXOR: DEFAULT Parsing Style

This parser attempts to combine the best features of Markdown and
LaTeX. This is all in taste and preferences of the author.

]]>
    </doc>
    <info>
        <entry key="lang">lexor</entry>
        <entry key="style">default</entry>
        <entry key="ver">0.0.1c9</entry>
        <entry key="description">
            <![CDATA[Parse Markdown and LaTeX elements. ]]>
        </entry>
        <entry key="license">BSD License</entry>
        <entry key="author">Manuel Lopez</entry>
        <entry key="author_email">jmlopez.rod@gmail.com</entry>
        <entry key="url">http://jmlopez-rod.github.io/lexor-lang/lexor-parser-default</entry>
        <entry key="version">(0, 0, 1, 'rc', 9)</entry>
        <entry key="type">parser</entry>
    </info>
    <defaults>
        <entry key="inline">
            <![CDATA['off']]>
        </entry>
    </defaults>
    <mapping>
        <entry key="#document">
            <checker>
                <![CDATA['\n']]>
            </checker>
            <processor module="lexor-lang_lexor_parser_default_meta" name="MetaNP"/>
            <processor module="lexor-lang_lexor_parser_default_empty" name="EmptyNP"/>
            <processor module="lexor-lang_lexor_parser_default_reference" name="ReferenceBlockNP"/>
            <processor module="lexor-lang_lexor_parser_default_code" name="CodeBlockNP"/>
            <processor module="lexor-lang_lexor_parser_default_header" name="AtxHeaderNP"/>
            <processor module="lexor-lang_lexor_parser_default_header" name="SetextHeaderNP"/>
            <processor module="lexor-lang_lexor_parser_default_latex" name="LatexDisplayNP"/>
            <processor module="lexor-lang_lexor_parser_default_entity" name="BreakNP"/>
            <processor module="lexor-lang_lexor_parser_default_cdata" name="CDataNP"/>
            <processor module="lexor-lang_lexor_parser_default_hr" name="HrNP"/>
            <processor module="lexor-lang_lexor_parser_default_doctype" name="DocumentTypeNP"/>
            <processor module="lexor-lang_lexor_parser_default_comment" name="CommentNP"/>
            <processor module="lexor-lang_lexor_parser_default_pi" name="ProcessingInstructionNP"/>
            <processor module="lexor-lang_lexor_parser_default_paragraph" name="ParagraphNP"/>
            <processor module="lexor-lang_lexor_parser_default_element" name="ElementNP"/>
        </entry>
        <entry key="__default__">
            <checker>
                <![CDATA['<&\\\\`\'"*_{}[\\]()#+-.!%$:\n']]>
            </checker>
            <processor module="lexor-lang_lexor_parser_default_code" name="CodeInlineNP"/>
            <processor module="lexor-lang_lexor_parser_default_reference" name="ReferenceInlineNP"/>
            <processor module="lexor-lang_lexor_parser_default_latex" name="LatexDisplayNP"/>
            <processor module="lexor-lang_lexor_parser_default_latex" name="LatexInlineNP"/>
            <processor module="lexor-lang_lexor_parser_default_inline" name="StrongEmNP"/>
            <processor module="lexor-lang_lexor_parser_default_inline" name="EmStrongNP"/>
            <processor module="lexor-lang_lexor_parser_default_inline" name="StrongNP"/>
            <processor module="lexor-lang_lexor_parser_default_inline" name="Strong2NP"/>
            <processor module="lexor-lang_lexor_parser_default_inline" name="EmNP"/>
            <processor module="lexor-lang_lexor_parser_default_inline" name="SmartEmNP"/>
            <processor module="lexor-lang_lexor_parser_default_quote" name="QuoteNP"/>
            <processor module="lexor-lang_lexor_parser_default_entity" name="BreakNP"/>
            <processor module="lexor-lang_lexor_parser_default_auto" name="AutoMailNP"/>
            <processor module="lexor-lang_lexor_parser_default_auto" name="AutoLinkNP"/>
            <processor module="lexor-lang_lexor_parser_default_element" name="ElementNP"/>
            <processor module="lexor-lang_lexor_parser_default_cdata" name="CDataNP"/>
            <processor module="lexor-lang_lexor_parser_default_doctype" name="DocumentTypeNP"/>
            <processor module="lexor-lang_lexor_parser_default_comment" name="CommentNP"/>
            <processor module="lexor-lang_lexor_parser_default_pi" name="ProcessingInstructionNP"/>
            <processor module="lexor-lang_lexor_parser_default_entity" name="EntityNP"/>
        </entry>
        <entry key="align">
            <checker>
                <![CDATA['%']]>
            </checker>
        </entry>
        <entry key="body" from-entry="#document"/>
        <entry key="codeblock">
            <checker>
                <![CDATA['<%']]>
            </checker>
        </entry>
        <entry key="define">
            <checker>
                <![CDATA['\n']]>
            </checker>
            <processor module="lexor-lang_lexor_parser_default_define" name="MacroNP"/>
        </entry>
        <entry key="equation">
            <checker>
                <![CDATA['%']]>
            </checker>
        </entry>
        <entry key="list">
            <checker>
                <![CDATA['\n']]>
            </checker>
            <processor module="lexor-lang_lexor_parser_default_list" name="ListNP"/>
        </entry>
        <entry key="list_item" from-entry="#document"/>
        <entry key="section" from-entry="#document"/>
    </mapping>
    <classes/>
    <functions>
        <function name="parser_setup">
            <argspec varargs="None" keywords="None">
                <args>
                    <arg name="parser"/>
                </args>
            </argspec>
            <doc>
                <![CDATA[Using options to configure the parser. ]]>
            </doc>
        </function>
    </functions>
    <data>
        <data name="REPOSITORY">
            <![CDATA[[<class 'lexor-lang_lexor_parser_default_auto.AutoLinkNP'>, <class 'lexor-lang_lexor_parser_default_auto.AutoMailNP'>, <class 'lexor-lang_lexor_parser_default_cdata.CDataNP'>, <class 'lexor-lang_lexor_parser_default_comment.CommentNP'>, <class 'lexor-lang_lexor_parser_default_code.CodeInlineNP'>, <class 'lexor-lang_lexor_parser_default_code.CodeBlockNP'>, <class 'lexor-lang_lexor_parser_default_define.MacroNP'>, <class 'lexor-lang_lexor_parser_default_doctype.DocumentTypeNP'>, <class 'lexor-lang_lexor_parser_default_element.ElementNP'>, <class 'lexor-lang_lexor_parser_default_empty.EmptyNP'>, <class 'lexor-lang_lexor_parser_default_entity.EntityNP'>, <class 'lexor-lang_lexor_parser_default_entity.BreakNP'>, <class 'lexor-lang_lexor_parser_default_header.AtxHeaderNP'>, <class 'lexor-lang_lexor_parser_default_header.SetextHeaderNP'>, <class 'lexor-lang_lexor_parser_default_hr.HrNP'>, <class 'lexor-lang_lexor_parser_default_inline.StrongEmNP'>, <class 'lexor-lang_lexor_parser_default_inline.EmStrongNP'>, <class 'lexor-lang_lexor_parser_default_inline.StrongNP'>, <class 'lexor-lang_lexor_parser_default_inline.Strong2NP'>, <class 'lexor-lang_lexor_parser_default_inline.EmNP'>, <class 'lexor-lang_lexor_parser_default_inline.SmartEmNP'>, <class 'lexor-lang_lexor_parser_default_latex.LatexDisplayNP'>, <class 'lexor-lang_lexor_parser_default_latex.LatexInlineNP'>, <class 'lexor-lang_lexor_parser_default_list.ListNP'>, <class 'lexor-lang_lexor_parser_default_meta.MetaNP'>, <class 'lexor-lang_lexor_parser_default_paragraph.ParagraphNP'>, <class 'lexor-lang_lexor_parser_default_pi.ProcessingInstructionNP'>, <class 'lexor-lang_lexor_parser_default_quote.QuoteNP'>, <class 'lexor-lang_lexor_parser_default_reference.ReferenceBlockNP'>, <class 'lexor-lang_lexor_parser_default_reference.ReferenceInlineNP'>]]]>
        </data>
        <data name="MOD">
            <![CDATA[{'comment': <module 'lexor-lang_lexor_parser_default_comment' from '/Users/jmlopez/github/lexor-lang-repos/lexor-parser-default/default/comment.pyc'>, 'latex': <module 'lexor-lang_lexor_parser_default_latex' from '/Users/jmlopez/github/lexor-lang-repos/lexor-parser-default/default/latex.pyc'>, 'code': <module 'lexor-lang_lexor_parser_default_code' from '/Users/jmlopez/github/lexor-lang-repos/lexor-parser-default/default/code.pyc'>, 'reference': <module 'lexor-lang_lexor_parser_default_reference' from '/Users/jmlopez/github/lexor-lang-repos/lexor-parser-default/default/reference.pyc'>, 'hr': <module 'lexor-lang_lexor_parser_default_hr' from '/Users/jmlopez/github/lexor-lang-repos/lexor-parser-default/default/hr.pyc'>, 'auto': <module 'lexor-lang_lexor_parser_default_auto' from '/Users/jmlopez/github/lexor-lang-repos/lexor-parser-default/default/auto.pyc'>, 'paragraph': <module 'lexor-lang_lexor_parser_default_paragraph' from '/Users/jmlopez/github/lexor-lang-repos/lexor-parser-default/default/paragraph.pyc'>, 'list': <module 'lexor-lang_lexor_parser_default_list' from '/Users/jmlopez/github/lexor-lang-repos/lexor-parser-default/default/list.pyc'>, 'doctype': <module 'lexor-lang_lexor_parser_default_doctype' from '/Users/jmlopez/github/lexor-lang-repos/lexor-parser-default/default/doctype.pyc'>, 'element': <module 'lexor-lang_lexor_parser_default_element' from '/Users/jmlopez/github/lexor-lang-repos/lexor-parser-default/default/element.pyc'>, 'header': <module 'lexor-lang_lexor_parser_default_header' from '/Users/jmlopez/github/lexor-lang-repos/lexor-parser-default/default/header.pyc'>, 'meta': <module 'lexor-lang_lexor_parser_default_meta' from '/Users/jmlopez/github/lexor-lang-repos/lexor-parser-default/default/meta.pyc'>, 'pi': <module 'lexor-lang_lexor_parser_default_pi' from '/Users/jmlopez/github/lexor-lang-repos/lexor-parser-default/default/pi.pyc'>, 'cdata': <module 'lexor-lang_lexor_parser_default_cdata' from '/Users/jmlopez/github/lexor-lang-repos/lexor-parser-default/default/cdata.pyc'>, 'quote': <module 'lexor-lang_lexor_parser_default_quote' from '/Users/jmlopez/github/lexor-lang-repos/lexor-parser-default/default/quote.pyc'>, 'inline': <module 'lexor-lang_lexor_parser_default_inline' from '/Users/jmlopez/github/lexor-lang-repos/lexor-parser-default/default/inline.pyc'>, 'entity': <module 'lexor-lang_lexor_parser_default_entity' from '/Users/jmlopez/github/lexor-lang-repos/lexor-parser-default/default/entity.pyc'>, 'empty': <module 'lexor-lang_lexor_parser_default_empty' from '/Users/jmlopez/github/lexor-lang-repos/lexor-parser-default/default/empty.pyc'>, 'define': <module 'lexor-lang_lexor_parser_default_define' from '/Users/jmlopez/github/lexor-lang-repos/lexor-parser-default/default/define.pyc'>}]]>
        </data>
    </data>
    <imports>
        <other fullname="lexor.command.lang.load_aux" type="function" name="load_aux"/>
        <other fullname="lexor.init" type="function" name="init"/>
    </imports>
</module>
<module name="lexor-lang_lexor_parser_default_doctype">
    <doc>
        <![CDATA[LEXOR: DOCTYPE NodeParser

DOCTYPE is case insensitive in HTML. The following forms are valid:

    <!doctype html>
    <!DOCTYPE html>
    <!DOCTYPE HTML>
    <!DoCtYpE hTmL>

New Form:

    %%!doctype html%%
    %%!DOCTYPE html%%
    %%!DOCTYPE HTML%%
    %%!DoCtYpE hTmL%%

See: http://stackoverflow.com/a/9109157/788553

]]>
    </doc>
    <classes>
        <class name="DocumentTypeNP">
            <bases>
                <base name="lexor.core.parser.NodeParser"/>
            </bases>
            <mro>
                <class name="lexor-lang_lexor_parser_default_doctype.DocumentTypeNP"/>
                <class name="lexor.core.parser.NodeParser"/>
                <class name="__builtin__.object"/>
            </mro>
            <doc>
                <![CDATA[Reads the doctype tag. ]]>
            </doc>
            <method_block from="lexor-lang_lexor_parser_default_doctype.DocumentTypeNP">
                <function name="_new_doctype">
                    <argspec varargs="None" keywords="None">
                        <args>
                            <arg name="self"/>
                            <arg name="parser"/>
                            <arg name="caret"/>
                        </args>
                    </argspec>
                    <doc>
                        <![CDATA[Parse new doctype. ]]>
                    </doc>
                </function>
                <function name="_regular_doctype">
                    <argspec varargs="None" keywords="None">
                        <args>
                            <arg name="self"/>
                            <arg name="parser"/>
                            <arg name="caret"/>
                        </args>
                    </argspec>
                    <doc>
                        <![CDATA[Parse regular doctype. ]]>
                    </doc>
                </function>
                <function name="make_node">
                    <argspec varargs="None" keywords="None">
                        <args>
                            <arg name="self"/>
                        </args>
                    </argspec>
                    <doc>
                        <![CDATA[Returns a DocumentType node. ]]>
                    </doc>
                </function>
            </method_block>
            <method_block from="lexor.core.parser.NodeParser">
                <function name="__init__">
                    <argspec varargs="None" keywords="None">
                        <args>
                            <arg name="self"/>
                            <arg name="parser"/>
                        </args>
                    </argspec>
                    <doc>
                        <![CDATA[A |NodeParser| needs to be initialized with a |Parser|
object. If this method is to be overloaded then make sure
that it only accepts one parameter: ``parser``. This method
is used by |Parser| and it calls it with itself as the
parameter.]]>
                    </doc>
                </function>
                <function name="close">
                    <argspec varargs="None" keywords="None">
                        <args>
                            <arg name="self"/>
                            <arg name="_"/>
                        </args>
                    </argspec>
                    <doc>
                        <![CDATA[This method needs to be overloaded if the node parser
returns a |Node| with the :meth:`make_node` method.

This method will not get called if :meth:`make_node` returned
a |Node| inside a ``list``. The close function takes as input
the node object that :meth:`make_node` returned and it should
decide if the node can be closed or not. If it is indeed time
to close the node then return a ``list`` with the position
where the node is being closed, otherwise return ``None``.

If this method is not overloaded then a
``NotImplementedError`` exception will be raised.]]>
                    </doc>
                </function>
                <function name="make_node">
                    <argspec varargs="None" keywords="None">
                        <args>
                            <arg name="self"/>
                        </args>
                    </argspec>
                    <doc>
                        <![CDATA[Returns a DocumentType node. ]]>
                    </doc>
                </function>
                <function name="msg">
                    <argspec varargs="None" keywords="None">
                        <args>
                            <arg name="self"/>
                            <arg name="code"/>
                            <arg name="pos"/>
                            <arg name="arg" default="None"/>
                            <arg name="uri" default="None"/>
                        </args>
                    </argspec>
                    <doc>
                        <![CDATA[Send a message to the parser by providing one of the error
codes defined in the style as well as the position where the
error took place. The position has the form of a list
containing the line and column number. Some error codes may
provide arguments, this can be passed to `arg`. In case the
error occurred somewhere not in the current document, perhaps
in a string, then you may provide a new `uri` to denote the
location.]]>
                    </doc>
                </function>
            </method_block>
            <member_block from="lexor.core.parser.NodeParser">
                <member name="__weakref__"/>
            </member_block>
            <method_block from="__builtin__.object">
                <function name="__init__">
                    <argspec varargs="None" keywords="None">
                        <args>
                            <arg name="self"/>
                            <arg name="parser"/>
                        </args>
                    </argspec>
                    <doc>
                        <![CDATA[A |NodeParser| needs to be initialized with a |Parser|
object. If this method is to be overloaded then make sure
that it only accepts one parameter: ``parser``. This method
is used by |Parser| and it calls it with itself as the
parameter.]]>
                    </doc>
                </function>
            </method_block>
        </class>
    </classes>
    <functions/>
    <data>
        <data name="MSG">
            <![CDATA[{'E100': '`{0}` not found'}]]>
        </data>
        <data name="MSG_EXPLANATION">
            <![CDATA[['\n    - A `doctype` element starts with `<!doctype` and it is\n      terminated by `>`.\n\n    Okay: <!doctype html>\n    Okay: <!DOCTYPE html>\n    Okay: %%!doctype html%%\n    Okay: %%!DOCTYPE html%%\n\n    E100: <!doctype html\n    E100: %%!doctype html\n']]]>
        </data>
    </data>
    <imports>
        <other fullname="lexor.core.parser.NodeParser" type="type" name="NodeParser"/>
        <other fullname="lexor.core.elements.DocumentType" type="type" name="DocumentType"/>
    </imports>
</module>
<module name="lexor-lang_lexor_parser_default_auto">
    <doc>
        <![CDATA[LEXOR: AUTO NodeParser

Contains the AutoMail and AutoLink node parsers.

]]>
    </doc>
    <classes>
        <class name="AutoMailNP">
            <bases>
                <base name="lexor.core.parser.NodeParser"/>
            </bases>
            <mro>
                <class name="lexor-lang_lexor_parser_default_auto.AutoMailNP"/>
                <class name="lexor.core.parser.NodeParser"/>
                <class name="__builtin__.object"/>
            </mro>
            <doc>
                <![CDATA[Parse email address enclosed by `<` and `>`. ]]>
            </doc>
            <method_block from="lexor-lang_lexor_parser_default_auto.AutoMailNP">
                <function name="make_node">
                    <argspec varargs="None" keywords="None">
                        <args>
                            <arg name="self"/>
                        </args>
                    </argspec>
                </function>
            </method_block>
            <method_block from="lexor.core.parser.NodeParser">
                <function name="__init__">
                    <argspec varargs="None" keywords="None">
                        <args>
                            <arg name="self"/>
                            <arg name="parser"/>
                        </args>
                    </argspec>
                    <doc>
                        <![CDATA[A |NodeParser| needs to be initialized with a |Parser|
object. If this method is to be overloaded then make sure
that it only accepts one parameter: ``parser``. This method
is used by |Parser| and it calls it with itself as the
parameter.]]>
                    </doc>
                </function>
                <function name="close">
                    <argspec varargs="None" keywords="None">
                        <args>
                            <arg name="self"/>
                            <arg name="_"/>
                        </args>
                    </argspec>
                    <doc>
                        <![CDATA[This method needs to be overloaded if the node parser
returns a |Node| with the :meth:`make_node` method.

This method will not get called if :meth:`make_node` returned
a |Node| inside a ``list``. The close function takes as input
the node object that :meth:`make_node` returned and it should
decide if the node can be closed or not. If it is indeed time
to close the node then return a ``list`` with the position
where the node is being closed, otherwise return ``None``.

If this method is not overloaded then a
``NotImplementedError`` exception will be raised.]]>
                    </doc>
                </function>
                <function name="make_node">
                    <argspec varargs="None" keywords="None">
                        <args>
                            <arg name="self"/>
                        </args>
                    </argspec>
                </function>
                <function name="msg">
                    <argspec varargs="None" keywords="None">
                        <args>
                            <arg name="self"/>
                            <arg name="code"/>
                            <arg name="pos"/>
                            <arg name="arg" default="None"/>
                            <arg name="uri" default="None"/>
                        </args>
                    </argspec>
                    <doc>
                        <![CDATA[Send a message to the parser by providing one of the error
codes defined in the style as well as the position where the
error took place. The position has the form of a list
containing the line and column number. Some error codes may
provide arguments, this can be passed to `arg`. In case the
error occurred somewhere not in the current document, perhaps
in a string, then you may provide a new `uri` to denote the
location.]]>
                    </doc>
                </function>
            </method_block>
            <member_block from="lexor.core.parser.NodeParser">
                <member name="__weakref__"/>
            </member_block>
            <method_block from="__builtin__.object">
                <function name="__init__">
                    <argspec varargs="None" keywords="None">
                        <args>
                            <arg name="self"/>
                            <arg name="parser"/>
                        </args>
                    </argspec>
                    <doc>
                        <![CDATA[A |NodeParser| needs to be initialized with a |Parser|
object. If this method is to be overloaded then make sure
that it only accepts one parameter: ``parser``. This method
is used by |Parser| and it calls it with itself as the
parameter.]]>
                    </doc>
                </function>
            </method_block>
        </class>
        <class name="AutoLinkNP">
            <bases>
                <base name="lexor.core.parser.NodeParser"/>
            </bases>
            <mro>
                <class name="lexor-lang_lexor_parser_default_auto.AutoLinkNP"/>
                <class name="lexor.core.parser.NodeParser"/>
                <class name="__builtin__.object"/>
            </mro>
            <doc>
                <![CDATA[Parse urls enclosed by `<` and `>`. ]]>
            </doc>
            <method_block from="lexor-lang_lexor_parser_default_auto.AutoLinkNP">
                <function name="make_node">
                    <argspec varargs="None" keywords="None">
                        <args>
                            <arg name="self"/>
                        </args>
                    </argspec>
                </function>
            </method_block>
            <method_block from="lexor.core.parser.NodeParser">
                <function name="__init__">
                    <argspec varargs="None" keywords="None">
                        <args>
                            <arg name="self"/>
                            <arg name="parser"/>
                        </args>
                    </argspec>
                    <doc>
                        <![CDATA[A |NodeParser| needs to be initialized with a |Parser|
object. If this method is to be overloaded then make sure
that it only accepts one parameter: ``parser``. This method
is used by |Parser| and it calls it with itself as the
parameter.]]>
                    </doc>
                </function>
                <function name="close">
                    <argspec varargs="None" keywords="None">
                        <args>
                            <arg name="self"/>
                            <arg name="_"/>
                        </args>
                    </argspec>
                    <doc>
                        <![CDATA[This method needs to be overloaded if the node parser
returns a |Node| with the :meth:`make_node` method.

This method will not get called if :meth:`make_node` returned
a |Node| inside a ``list``. The close function takes as input
the node object that :meth:`make_node` returned and it should
decide if the node can be closed or not. If it is indeed time
to close the node then return a ``list`` with the position
where the node is being closed, otherwise return ``None``.

If this method is not overloaded then a
``NotImplementedError`` exception will be raised.]]>
                    </doc>
                </function>
                <function name="make_node">
                    <argspec varargs="None" keywords="None">
                        <args>
                            <arg name="self"/>
                        </args>
                    </argspec>
                </function>
                <function name="msg">
                    <argspec varargs="None" keywords="None">
                        <args>
                            <arg name="self"/>
                            <arg name="code"/>
                            <arg name="pos"/>
                            <arg name="arg" default="None"/>
                            <arg name="uri" default="None"/>
                        </args>
                    </argspec>
                    <doc>
                        <![CDATA[Send a message to the parser by providing one of the error
codes defined in the style as well as the position where the
error took place. The position has the form of a list
containing the line and column number. Some error codes may
provide arguments, this can be passed to `arg`. In case the
error occurred somewhere not in the current document, perhaps
in a string, then you may provide a new `uri` to denote the
location.]]>
                    </doc>
                </function>
            </method_block>
            <member_block from="lexor.core.parser.NodeParser">
                <member name="__weakref__"/>
            </member_block>
            <method_block from="__builtin__.object">
                <function name="__init__">
                    <argspec varargs="None" keywords="None">
                        <args>
                            <arg name="self"/>
                            <arg name="parser"/>
                        </args>
                    </argspec>
                    <doc>
                        <![CDATA[A |NodeParser| needs to be initialized with a |Parser|
object. If this method is to be overloaded then make sure
that it only accepts one parameter: ``parser``. This method
is used by |Parser| and it calls it with itself as the
parameter.]]>
                    </doc>
                </function>
            </method_block>
        </class>
    </classes>
    <functions/>
    <data>
        <data name="URL_RE">
            <![CDATA[<_sre.SRE_Pattern object at 0x106136cb0>]]>
        </data>
        <data name="MAIL_RE">
            <![CDATA[<_sre.SRE_Pattern object at 0x10662b410>]]>
        </data>
    </data>
    <imports>
        <module fullname="re" name="re"/>
        <other fullname="lexor.core.elements.Element" type="type" name="Element"/>
        <other fullname="lexor.core.elements.Text" type="type" name="Text"/>
        <other fullname="lexor.core.parser.NodeParser" type="type" name="NodeParser"/>
    </imports>
</module>
<module name="lexor-lang_lexor_parser_default_paragraph">
    <doc>
        <![CDATA[LEXOR: PARAGRAPH NodeParser

Node parser description.

]]>
    </doc>
    <classes>
        <class name="ParagraphNP">
            <bases>
                <base name="lexor.core.parser.NodeParser"/>
            </bases>
            <mro>
                <class name="lexor-lang_lexor_parser_default_paragraph.ParagraphNP"/>
                <class name="lexor.core.parser.NodeParser"/>
                <class name="__builtin__.object"/>
            </mro>
            <doc>
                <![CDATA[Checks for valid paragraphs. ]]>
            </doc>
            <method_block from="lexor-lang_lexor_parser_default_paragraph.ParagraphNP">
                <function name="close">
                    <argspec varargs="None" keywords="None">
                        <args>
                            <arg name="self"/>
                            <arg name="node"/>
                        </args>
                    </argspec>
                    <doc>
                        <![CDATA[Returns the position where the element was closed. ]]>
                    </doc>
                </function>
                <function name="make_node">
                    <argspec varargs="None" keywords="None">
                        <args>
                            <arg name="self"/>
                        </args>
                    </argspec>
                    <doc>
                        <![CDATA[Returns a paragraph element. ]]>
                    </doc>
                </function>
            </method_block>
            <method_block from="lexor.core.parser.NodeParser">
                <function name="__init__">
                    <argspec varargs="None" keywords="None">
                        <args>
                            <arg name="self"/>
                            <arg name="parser"/>
                        </args>
                    </argspec>
                    <doc>
                        <![CDATA[A |NodeParser| needs to be initialized with a |Parser|
object. If this method is to be overloaded then make sure
that it only accepts one parameter: ``parser``. This method
is used by |Parser| and it calls it with itself as the
parameter.]]>
                    </doc>
                </function>
                <function name="close">
                    <argspec varargs="None" keywords="None">
                        <args>
                            <arg name="self"/>
                            <arg name="node"/>
                        </args>
                    </argspec>
                    <doc>
                        <![CDATA[Returns the position where the element was closed. ]]>
                    </doc>
                </function>
                <function name="make_node">
                    <argspec varargs="None" keywords="None">
                        <args>
                            <arg name="self"/>
                        </args>
                    </argspec>
                    <doc>
                        <![CDATA[Returns a paragraph element. ]]>
                    </doc>
                </function>
                <function name="msg">
                    <argspec varargs="None" keywords="None">
                        <args>
                            <arg name="self"/>
                            <arg name="code"/>
                            <arg name="pos"/>
                            <arg name="arg" default="None"/>
                            <arg name="uri" default="None"/>
                        </args>
                    </argspec>
                    <doc>
                        <![CDATA[Send a message to the parser by providing one of the error
codes defined in the style as well as the position where the
error took place. The position has the form of a list
containing the line and column number. Some error codes may
provide arguments, this can be passed to `arg`. In case the
error occurred somewhere not in the current document, perhaps
in a string, then you may provide a new `uri` to denote the
location.]]>
                    </doc>
                </function>
            </method_block>
            <member_block from="lexor.core.parser.NodeParser">
                <member name="__weakref__"/>
            </member_block>
            <method_block from="__builtin__.object">
                <function name="__init__">
                    <argspec varargs="None" keywords="None">
                        <args>
                            <arg name="self"/>
                            <arg name="parser"/>
                        </args>
                    </argspec>
                    <doc>
                        <![CDATA[A |NodeParser| needs to be initialized with a |Parser|
object. If this method is to be overloaded then make sure
that it only accepts one parameter: ``parser``. This method
is used by |Parser| and it calls it with itself as the
parameter.]]>
                    </doc>
                </function>
            </method_block>
        </class>
    </classes>
    <functions/>
    <data>
        <data name="VALID_TAGS">
            <![CDATA[['a', 'abbr', 'acronym', 'b', 'basefont', 'bdo', 'big', 'br', 'button', 'cite', 'code', 'dfn', 'em', 'font', 'i', 'img', 'input', 'kbd', 'label', 'map', 'object', 'q', 's', 'samp', 'select', 'small', 'span', 'strike', 'strong', 'sub', 'sup', 'textarea', 'tt', 'u', 'var']]]>
        </data>
        <data name="EMPTY_RE">
            <![CDATA[<_sre.SRE_Pattern object at 0x10667b670>]]>
        </data>
        <data name="INVALID_TAGS">
            <![CDATA[['address', 'article', 'aside', 'blockquote', 'dir', 'div', 'dl', 'fieldset', 'footer', 'form', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'header', 'hgroup', 'hr', 'main', 'menu', 'nav', 'ol', 'p', 'pre', 'section', 'table', 'ul']]]>
        </data>
        <data name="MSG">
            <![CDATA[{'E100': 'paragraph at {0}:{1} closed due to opening tag `{2}`'}]]>
        </data>
        <data name="MSG_EXPLANATION">
            <![CDATA[["\n    - Only a few tags are allowed as children of a `p` tag. The\n      paragraph tag is forced to close when one of the following tags\n      is encountered.\n\n        'address', 'article', 'aside', 'blockquote', 'dir', 'div',\n        'dl', 'fieldset', 'footer', 'form', 'h1', 'h2', 'h3', 'h4',\n        'h5', 'h6', 'header', 'hgroup', 'hr', 'main', 'menu', 'nav',\n        'ol', 'p', 'pre', 'section', 'table', 'ul',\n\n    Okay:\n        This is line 1 with <strong>bold</strong> font.\n        This is line 2 with <em>italic</em> font.\n\n    E100:\n        This is line 1 with <h1>header 1</h1>.\n        This is line 2 with <h2>header 2</h2>.\n"]]]>
        </data>
    </data>
    <imports>
        <module fullname="re" name="re"/>
        <other fullname="lexor.core.elements.Element" type="type" name="Element"/>
        <other fullname="lexor.core.parser.NodeParser" type="type" name="NodeParser"/>
    </imports>
</module>
<module name="lexor-lang_lexor_parser_default_hr">
    <doc>
        <![CDATA[LEXOR: HR NodeParser

Processes horizontal rules.

]]>
    </doc>
    <classes>
        <class name="HrNP">
            <bases>
                <base name="lexor.core.parser.NodeParser"/>
            </bases>
            <mro>
                <class name="lexor-lang_lexor_parser_default_hr.HrNP"/>
                <class name="lexor.core.parser.NodeParser"/>
                <class name="__builtin__.object"/>
            </mro>
            <doc>
                <![CDATA[Capture horizontal rules. ]]>
            </doc>
            <method_block from="lexor-lang_lexor_parser_default_hr.HrNP">
                <function name="make_node">
                    <argspec varargs="None" keywords="None">
                        <args>
                            <arg name="self"/>
                        </args>
                    </argspec>
                </function>
            </method_block>
            <method_block from="lexor.core.parser.NodeParser">
                <function name="__init__">
                    <argspec varargs="None" keywords="None">
                        <args>
                            <arg name="self"/>
                            <arg name="parser"/>
                        </args>
                    </argspec>
                    <doc>
                        <![CDATA[A |NodeParser| needs to be initialized with a |Parser|
object. If this method is to be overloaded then make sure
that it only accepts one parameter: ``parser``. This method
is used by |Parser| and it calls it with itself as the
parameter.]]>
                    </doc>
                </function>
                <function name="close">
                    <argspec varargs="None" keywords="None">
                        <args>
                            <arg name="self"/>
                            <arg name="_"/>
                        </args>
                    </argspec>
                    <doc>
                        <![CDATA[This method needs to be overloaded if the node parser
returns a |Node| with the :meth:`make_node` method.

This method will not get called if :meth:`make_node` returned
a |Node| inside a ``list``. The close function takes as input
the node object that :meth:`make_node` returned and it should
decide if the node can be closed or not. If it is indeed time
to close the node then return a ``list`` with the position
where the node is being closed, otherwise return ``None``.

If this method is not overloaded then a
``NotImplementedError`` exception will be raised.]]>
                    </doc>
                </function>
                <function name="make_node">
                    <argspec varargs="None" keywords="None">
                        <args>
                            <arg name="self"/>
                        </args>
                    </argspec>
                </function>
                <function name="msg">
                    <argspec varargs="None" keywords="None">
                        <args>
                            <arg name="self"/>
                            <arg name="code"/>
                            <arg name="pos"/>
                            <arg name="arg" default="None"/>
                            <arg name="uri" default="None"/>
                        </args>
                    </argspec>
                    <doc>
                        <![CDATA[Send a message to the parser by providing one of the error
codes defined in the style as well as the position where the
error took place. The position has the form of a list
containing the line and column number. Some error codes may
provide arguments, this can be passed to `arg`. In case the
error occurred somewhere not in the current document, perhaps
in a string, then you may provide a new `uri` to denote the
location.]]>
                    </doc>
                </function>
            </method_block>
            <member_block from="lexor.core.parser.NodeParser">
                <member name="__weakref__"/>
            </member_block>
            <method_block from="__builtin__.object">
                <function name="__init__">
                    <argspec varargs="None" keywords="None">
                        <args>
                            <arg name="self"/>
                            <arg name="parser"/>
                        </args>
                    </argspec>
                    <doc>
                        <![CDATA[A |NodeParser| needs to be initialized with a |Parser|
object. If this method is to be overloaded then make sure
that it only accepts one parameter: ``parser``. This method
is used by |Parser| and it calls it with itself as the
parameter.]]>
                    </doc>
                </function>
            </method_block>
        </class>
    </classes>
    <functions/>
    <data>
        <data name="RE">
            <![CDATA[<_sre.SRE_Pattern object at 0x7f86385c5ff0>]]>
        </data>
    </data>
    <imports>
        <module fullname="re" name="re"/>
        <other fullname="lexor.core.parser.NodeParser" type="type" name="NodeParser"/>
        <other fullname="lexor.core.elements.Void" type="type" name="Void"/>
    </imports>
</module>
<module name="lexor-lang_lexor_parser_default_meta">
    <doc>
        <![CDATA[LEXOR: META NodeParser

Obtains the meta information on a document.

]]>
    </doc>
    <classes>
        <class name="MetaNP">
            <bases>
                <base name="lexor.core.parser.NodeParser"/>
            </bases>
            <mro>
                <class name="lexor-lang_lexor_parser_default_meta.MetaNP"/>
                <class name="lexor.core.parser.NodeParser"/>
                <class name="__builtin__.object"/>
            </mro>
            <doc>
                <![CDATA[Obtain the meta information. ]]>
            </doc>
            <method_block from="lexor-lang_lexor_parser_default_meta.MetaNP">
                <function name="make_node">
                    <argspec varargs="None" keywords="None">
                        <args>
                            <arg name="self"/>
                        </args>
                    </argspec>
                </function>
            </method_block>
            <method_block from="lexor.core.parser.NodeParser">
                <function name="__init__">
                    <argspec varargs="None" keywords="None">
                        <args>
                            <arg name="self"/>
                            <arg name="parser"/>
                        </args>
                    </argspec>
                    <doc>
                        <![CDATA[A |NodeParser| needs to be initialized with a |Parser|
object. If this method is to be overloaded then make sure
that it only accepts one parameter: ``parser``. This method
is used by |Parser| and it calls it with itself as the
parameter.]]>
                    </doc>
                </function>
                <function name="close">
                    <argspec varargs="None" keywords="None">
                        <args>
                            <arg name="self"/>
                            <arg name="_"/>
                        </args>
                    </argspec>
                    <doc>
                        <![CDATA[This method needs to be overloaded if the node parser
returns a |Node| with the :meth:`make_node` method.

This method will not get called if :meth:`make_node` returned
a |Node| inside a ``list``. The close function takes as input
the node object that :meth:`make_node` returned and it should
decide if the node can be closed or not. If it is indeed time
to close the node then return a ``list`` with the position
where the node is being closed, otherwise return ``None``.

If this method is not overloaded then a
``NotImplementedError`` exception will be raised.]]>
                    </doc>
                </function>
                <function name="make_node">
                    <argspec varargs="None" keywords="None">
                        <args>
                            <arg name="self"/>
                        </args>
                    </argspec>
                </function>
                <function name="msg">
                    <argspec varargs="None" keywords="None">
                        <args>
                            <arg name="self"/>
                            <arg name="code"/>
                            <arg name="pos"/>
                            <arg name="arg" default="None"/>
                            <arg name="uri" default="None"/>
                        </args>
                    </argspec>
                    <doc>
                        <![CDATA[Send a message to the parser by providing one of the error
codes defined in the style as well as the position where the
error took place. The position has the form of a list
containing the line and column number. Some error codes may
provide arguments, this can be passed to `arg`. In case the
error occurred somewhere not in the current document, perhaps
in a string, then you may provide a new `uri` to denote the
location.]]>
                    </doc>
                </function>
            </method_block>
            <member_block from="lexor.core.parser.NodeParser">
                <member name="__weakref__"/>
            </member_block>
            <method_block from="__builtin__.object">
                <function name="__init__">
                    <argspec varargs="None" keywords="None">
                        <args>
                            <arg name="self"/>
                            <arg name="parser"/>
                        </args>
                    </argspec>
                    <doc>
                        <![CDATA[A |NodeParser| needs to be initialized with a |Parser|
object. If this method is to be overloaded then make sure
that it only accepts one parameter: ``parser``. This method
is used by |Parser| and it calls it with itself as the
parameter.]]>
                    </doc>
                </function>
            </method_block>
        </class>
    </classes>
    <functions/>
    <imports>
        <other fullname="lexor.core.elements.RawText" type="type" name="RawText"/>
        <other fullname="lexor.core.parser.NodeParser" type="type" name="NodeParser"/>
        <other fullname="lexor.core.elements.Element" type="type" name="Element"/>
    </imports>
</module>
<module name="lexor-lang_lexor_parser_default_comment">
    <doc>
        <![CDATA[LEXOR: COMMENT NodeParser

Comments as in HTML are enclosed within `<!--` and `-->`. The string
`--` (double-hyphen) MUST NOT occur within comments. Unlike the HTML
parser the comment may start with `<!`. Another form of comment is
enclosed within `%%!` and `%%`. If the last form is used then the
comment may not contain the string '%%'.

See: http://www.w3.org/TR/REC-xml/#sec-comments

]]>
    </doc>
    <classes>
        <class name="CommentNP">
            <bases>
                <base name="lexor.core.parser.NodeParser"/>
            </bases>
            <mro>
                <class name="lexor-lang_lexor_parser_default_comment.CommentNP"/>
                <class name="lexor.core.parser.NodeParser"/>
                <class name="__builtin__.object"/>
            </mro>
            <doc>
                <![CDATA[Lexor comment parser. ]]>
            </doc>
            <method_block from="lexor-lang_lexor_parser_default_comment.CommentNP">
                <function name="_new_comment">
                    <argspec varargs="None" keywords="None">
                        <args>
                            <arg name="self"/>
                            <arg name="parser"/>
                            <arg name="caret"/>
                        </args>
                    </argspec>
                    <doc>
                        <![CDATA[parse new style comment. ]]>
                    </doc>
                </function>
                <function name="_regular_comment">
                    <argspec varargs="None" keywords="None">
                        <args>
                            <arg name="self"/>
                            <arg name="parser"/>
                            <arg name="caret"/>
                        </args>
                    </argspec>
                    <doc>
                        <![CDATA[Parse regular comments. ]]>
                    </doc>
                </function>
                <function name="make_node">
                    <argspec varargs="None" keywords="None">
                        <args>
                            <arg name="self"/>
                        </args>
                    </argspec>
                </function>
            </method_block>
            <method_block from="lexor.core.parser.NodeParser">
                <function name="__init__">
                    <argspec varargs="None" keywords="None">
                        <args>
                            <arg name="self"/>
                            <arg name="parser"/>
                        </args>
                    </argspec>
                    <doc>
                        <![CDATA[A |NodeParser| needs to be initialized with a |Parser|
object. If this method is to be overloaded then make sure
that it only accepts one parameter: ``parser``. This method
is used by |Parser| and it calls it with itself as the
parameter.]]>
                    </doc>
                </function>
                <function name="close">
                    <argspec varargs="None" keywords="None">
                        <args>
                            <arg name="self"/>
                            <arg name="_"/>
                        </args>
                    </argspec>
                    <doc>
                        <![CDATA[This method needs to be overloaded if the node parser
returns a |Node| with the :meth:`make_node` method.

This method will not get called if :meth:`make_node` returned
a |Node| inside a ``list``. The close function takes as input
the node object that :meth:`make_node` returned and it should
decide if the node can be closed or not. If it is indeed time
to close the node then return a ``list`` with the position
where the node is being closed, otherwise return ``None``.

If this method is not overloaded then a
``NotImplementedError`` exception will be raised.]]>
                    </doc>
                </function>
                <function name="make_node">
                    <argspec varargs="None" keywords="None">
                        <args>
                            <arg name="self"/>
                        </args>
                    </argspec>
                </function>
                <function name="msg">
                    <argspec varargs="None" keywords="None">
                        <args>
                            <arg name="self"/>
                            <arg name="code"/>
                            <arg name="pos"/>
                            <arg name="arg" default="None"/>
                            <arg name="uri" default="None"/>
                        </args>
                    </argspec>
                    <doc>
                        <![CDATA[Send a message to the parser by providing one of the error
codes defined in the style as well as the position where the
error took place. The position has the form of a list
containing the line and column number. Some error codes may
provide arguments, this can be passed to `arg`. In case the
error occurred somewhere not in the current document, perhaps
in a string, then you may provide a new `uri` to denote the
location.]]>
                    </doc>
                </function>
            </method_block>
            <member_block from="lexor.core.parser.NodeParser">
                <member name="__weakref__"/>
            </member_block>
            <method_block from="__builtin__.object">
                <function name="__init__">
                    <argspec varargs="None" keywords="None">
                        <args>
                            <arg name="self"/>
                            <arg name="parser"/>
                        </args>
                    </argspec>
                    <doc>
                        <![CDATA[A |NodeParser| needs to be initialized with a |Parser|
object. If this method is to be overloaded then make sure
that it only accepts one parameter: ``parser``. This method
is used by |Parser| and it calls it with itself as the
parameter.]]>
                    </doc>
                </function>
            </method_block>
        </class>
    </classes>
    <functions/>
    <data>
        <data name="MSG">
            <![CDATA[{'E200': '`-->` not found', 'E100': 'comment closing delimiter not found'}]]>
        </data>
        <data name="MSG_EXPLANATION">
            <![CDATA[['\n    - A comment started with `<!--` must end with `-->`. If the\n      comment started with `<!` then you are only required to finish\n      it with `>`. Note that in this case your comment cannot contain\n      the greater than sign.\n\n    - A comment started with `%%!` must end with `%%`. In this case\n      you cannot write `%%` inside the comment.\n\n    Okay: <!--simple comment-->\n    Okay: <!simple comment>\n    Okay: %%!simple comment%%\n\n    E100: <!simple comment\n    E100: <!simple comment%%\n    E100: %%!simple comment\n    E200: <!--simple comment>\n']]]>
        </data>
    </data>
    <imports>
        <other fullname="lexor.core.elements.Comment" type="type" name="Comment"/>
        <other fullname="lexor.core.parser.NodeParser" type="type" name="NodeParser"/>
        <other fullname="lexor.core.writer.replace" type="function" name="replace"/>
    </imports>
</module>
<module name="lexor-lang_lexor_parser_default_empty">
    <doc>
        <![CDATA[LEXOR: EMPTY NodeParser]]>
    </doc>
    <classes>
        <class name="EmptyNP">
            <bases>
                <base name="lexor.core.parser.NodeParser"/>
            </bases>
            <mro>
                <class name="lexor-lang_lexor_parser_default_empty.EmptyNP"/>
                <class name="lexor.core.parser.NodeParser"/>
                <class name="__builtin__.object"/>
            </mro>
            <doc>
                <![CDATA[Collect empty spaces. ]]>
            </doc>
            <method_block from="lexor-lang_lexor_parser_default_empty.EmptyNP">
                <function name="make_node">
                    <argspec varargs="None" keywords="None">
                        <args>
                            <arg name="self"/>
                        </args>
                    </argspec>
                </function>
            </method_block>
            <method_block from="lexor.core.parser.NodeParser">
                <function name="__init__">
                    <argspec varargs="None" keywords="None">
                        <args>
                            <arg name="self"/>
                            <arg name="parser"/>
                        </args>
                    </argspec>
                    <doc>
                        <![CDATA[A |NodeParser| needs to be initialized with a |Parser|
object. If this method is to be overloaded then make sure
that it only accepts one parameter: ``parser``. This method
is used by |Parser| and it calls it with itself as the
parameter.]]>
                    </doc>
                </function>
                <function name="close">
                    <argspec varargs="None" keywords="None">
                        <args>
                            <arg name="self"/>
                            <arg name="_"/>
                        </args>
                    </argspec>
                    <doc>
                        <![CDATA[This method needs to be overloaded if the node parser
returns a |Node| with the :meth:`make_node` method.

This method will not get called if :meth:`make_node` returned
a |Node| inside a ``list``. The close function takes as input
the node object that :meth:`make_node` returned and it should
decide if the node can be closed or not. If it is indeed time
to close the node then return a ``list`` with the position
where the node is being closed, otherwise return ``None``.

If this method is not overloaded then a
``NotImplementedError`` exception will be raised.]]>
                    </doc>
                </function>
                <function name="make_node">
                    <argspec varargs="None" keywords="None">
                        <args>
                            <arg name="self"/>
                        </args>
                    </argspec>
                </function>
                <function name="msg">
                    <argspec varargs="None" keywords="None">
                        <args>
                            <arg name="self"/>
                            <arg name="code"/>
                            <arg name="pos"/>
                            <arg name="arg" default="None"/>
                            <arg name="uri" default="None"/>
                        </args>
                    </argspec>
                    <doc>
                        <![CDATA[Send a message to the parser by providing one of the error
codes defined in the style as well as the position where the
error took place. The position has the form of a list
containing the line and column number. Some error codes may
provide arguments, this can be passed to `arg`. In case the
error occurred somewhere not in the current document, perhaps
in a string, then you may provide a new `uri` to denote the
location.]]>
                    </doc>
                </function>
            </method_block>
            <member_block from="lexor.core.parser.NodeParser">
                <member name="__weakref__"/>
            </member_block>
            <method_block from="__builtin__.object">
                <function name="__init__">
                    <argspec varargs="None" keywords="None">
                        <args>
                            <arg name="self"/>
                            <arg name="parser"/>
                        </args>
                    </argspec>
                    <doc>
                        <![CDATA[A |NodeParser| needs to be initialized with a |Parser|
object. If this method is to be overloaded then make sure
that it only accepts one parameter: ``parser``. This method
is used by |Parser| and it calls it with itself as the
parameter.]]>
                    </doc>
                </function>
            </method_block>
        </class>
    </classes>
    <functions/>
    <data>
        <data name="RE">
            <![CDATA[<_sre.SRE_Pattern object at 0x10667b670>]]>
        </data>
    </data>
    <imports>
        <module fullname="re" name="re"/>
        <other fullname="lexor.core.elements.Text" type="type" name="Text"/>
        <other fullname="lexor.core.parser.NodeParser" type="type" name="NodeParser"/>
    </imports>
</module>
<module name="lexor-lang_lexor_parser_default_define">
    <doc>
        <![CDATA[LEXOR: DEFINE NodeParser

Node parser description.

]]>
    </doc>
    <classes>
        <class name="MacroNP">
            <bases>
                <base name="lexor.core.parser.NodeParser"/>
            </bases>
            <mro>
                <class name="lexor-lang_lexor_parser_default_define.MacroNP"/>
                <class name="lexor.core.parser.NodeParser"/>
                <class name="__builtin__.object"/>
            </mro>
            <doc>
                <![CDATA[Parse elements inside the define block. ]]>
            </doc>
            <method_block from="lexor-lang_lexor_parser_default_define.MacroNP">
                <function name="get_function">
                    <argspec varargs="None" keywords="None">
                        <args>
                            <arg name="self"/>
                            <arg name="pos"/>
                            <arg name="exp"/>
                        </args>
                    </argspec>
                    <doc>
                        <![CDATA[Obtain the function name. ]]>
                    </doc>
                </function>
                <function name="make_node">
                    <argspec varargs="None" keywords="None">
                        <args>
                            <arg name="self"/>
                        </args>
                    </argspec>
                </function>
            </method_block>
            <method_block from="lexor.core.parser.NodeParser">
                <function name="__init__">
                    <argspec varargs="None" keywords="None">
                        <args>
                            <arg name="self"/>
                            <arg name="parser"/>
                        </args>
                    </argspec>
                    <doc>
                        <![CDATA[A |NodeParser| needs to be initialized with a |Parser|
object. If this method is to be overloaded then make sure
that it only accepts one parameter: ``parser``. This method
is used by |Parser| and it calls it with itself as the
parameter.]]>
                    </doc>
                </function>
                <function name="close">
                    <argspec varargs="None" keywords="None">
                        <args>
                            <arg name="self"/>
                            <arg name="_"/>
                        </args>
                    </argspec>
                    <doc>
                        <![CDATA[This method needs to be overloaded if the node parser
returns a |Node| with the :meth:`make_node` method.

This method will not get called if :meth:`make_node` returned
a |Node| inside a ``list``. The close function takes as input
the node object that :meth:`make_node` returned and it should
decide if the node can be closed or not. If it is indeed time
to close the node then return a ``list`` with the position
where the node is being closed, otherwise return ``None``.

If this method is not overloaded then a
``NotImplementedError`` exception will be raised.]]>
                    </doc>
                </function>
                <function name="make_node">
                    <argspec varargs="None" keywords="None">
                        <args>
                            <arg name="self"/>
                        </args>
                    </argspec>
                </function>
                <function name="msg">
                    <argspec varargs="None" keywords="None">
                        <args>
                            <arg name="self"/>
                            <arg name="code"/>
                            <arg name="pos"/>
                            <arg name="arg" default="None"/>
                            <arg name="uri" default="None"/>
                        </args>
                    </argspec>
                    <doc>
                        <![CDATA[Send a message to the parser by providing one of the error
codes defined in the style as well as the position where the
error took place. The position has the form of a list
containing the line and column number. Some error codes may
provide arguments, this can be passed to `arg`. In case the
error occurred somewhere not in the current document, perhaps
in a string, then you may provide a new `uri` to denote the
location.]]>
                    </doc>
                </function>
            </method_block>
            <member_block from="lexor.core.parser.NodeParser">
                <member name="__weakref__"/>
            </member_block>
            <method_block from="__builtin__.object">
                <function name="__init__">
                    <argspec varargs="None" keywords="None">
                        <args>
                            <arg name="self"/>
                            <arg name="parser"/>
                        </args>
                    </argspec>
                    <doc>
                        <![CDATA[A |NodeParser| needs to be initialized with a |Parser|
object. If this method is to be overloaded then make sure
that it only accepts one parameter: ``parser``. This method
is used by |Parser| and it calls it with itself as the
parameter.]]>
                    </doc>
                </function>
            </method_block>
        </class>
    </classes>
    <functions/>
    <data>
        <data name="RE">
            <![CDATA[<_sre.SRE_Pattern object at 0x106642750>]]>
        </data>
        <data name="MSG">
            <![CDATA[{'E100': 'no `=` or `:=` found in macro declaration', 'E101': 'missing `{0}` in macro function definition'}]]>
        </data>
        <data name="MSG_EXPLANATION">
            <![CDATA[['\n    - A macro element can only be defined inside a define element.\n      It must have `=` or `:=` and in case of a function it must\n      start with `\\\\` and contain parameters inside `{...}`.\n\n    - When using parameters they must be within `:`, that is, if\n      `exp` is a paramter then you may use `:exp:` to refer to it\n      inside the function definition.\n\n    Okay:\n        %%{define}\n        x = 100\n        \\\\SET{exp} := \\left\\{:exp:\\right\\}\n        %%\n\n    E100:\n        %%{define}\n        x 100\n        \\\\SET{exp} := \\left\\{:exp:\\right\\}\n        %%\n    E101:\n        %%{define}\n        x = 100\n        \\\\SET := \\left\\{:exp:\\right\\}\n        %%\n']]]>
        </data>
    </data>
    <imports>
        <module fullname="re" name="re"/>
        <other fullname="collections.OrderedDict" type="type" name="OrderedDict"/>
        <other fullname="lexor.core.parser.NodeParser" type="type" name="NodeParser"/>
        <other fullname="lexor.core.elements.Void" type="type" name="Void"/>
    </imports>
</module>
<module name="lexor-lang_lexor_parser_default_entity">
    <doc>
        <![CDATA[LEXOR: ENTITY NodeParser

Some characters are special in HTML and LaTeX. This parser identifies
them and places them in an Entity node.

]]>
    </doc>
    <classes>
        <class name="BreakNP">
            <bases>
                <base name="lexor.core.parser.NodeParser"/>
            </bases>
            <mro>
                <class name="lexor-lang_lexor_parser_default_entity.BreakNP"/>
                <class name="lexor.core.parser.NodeParser"/>
                <class name="__builtin__.object"/>
            </mro>
            <doc>
                <![CDATA[Obtains the line break. ]]>
            </doc>
            <method_block from="lexor-lang_lexor_parser_default_entity.BreakNP">
                <function name="make_node">
                    <argspec varargs="None" keywords="None">
                        <args>
                            <arg name="self"/>
                        </args>
                    </argspec>
                </function>
            </method_block>
            <method_block from="lexor.core.parser.NodeParser">
                <function name="__init__">
                    <argspec varargs="None" keywords="None">
                        <args>
                            <arg name="self"/>
                            <arg name="parser"/>
                        </args>
                    </argspec>
                    <doc>
                        <![CDATA[A |NodeParser| needs to be initialized with a |Parser|
object. If this method is to be overloaded then make sure
that it only accepts one parameter: ``parser``. This method
is used by |Parser| and it calls it with itself as the
parameter.]]>
                    </doc>
                </function>
                <function name="close">
                    <argspec varargs="None" keywords="None">
                        <args>
                            <arg name="self"/>
                            <arg name="_"/>
                        </args>
                    </argspec>
                    <doc>
                        <![CDATA[This method needs to be overloaded if the node parser
returns a |Node| with the :meth:`make_node` method.

This method will not get called if :meth:`make_node` returned
a |Node| inside a ``list``. The close function takes as input
the node object that :meth:`make_node` returned and it should
decide if the node can be closed or not. If it is indeed time
to close the node then return a ``list`` with the position
where the node is being closed, otherwise return ``None``.

If this method is not overloaded then a
``NotImplementedError`` exception will be raised.]]>
                    </doc>
                </function>
                <function name="make_node">
                    <argspec varargs="None" keywords="None">
                        <args>
                            <arg name="self"/>
                        </args>
                    </argspec>
                </function>
                <function name="msg">
                    <argspec varargs="None" keywords="None">
                        <args>
                            <arg name="self"/>
                            <arg name="code"/>
                            <arg name="pos"/>
                            <arg name="arg" default="None"/>
                            <arg name="uri" default="None"/>
                        </args>
                    </argspec>
                    <doc>
                        <![CDATA[Send a message to the parser by providing one of the error
codes defined in the style as well as the position where the
error took place. The position has the form of a list
containing the line and column number. Some error codes may
provide arguments, this can be passed to `arg`. In case the
error occurred somewhere not in the current document, perhaps
in a string, then you may provide a new `uri` to denote the
location.]]>
                    </doc>
                </function>
            </method_block>
            <member_block from="lexor.core.parser.NodeParser">
                <member name="__weakref__"/>
            </member_block>
            <method_block from="__builtin__.object">
                <function name="__init__">
                    <argspec varargs="None" keywords="None">
                        <args>
                            <arg name="self"/>
                            <arg name="parser"/>
                        </args>
                    </argspec>
                    <doc>
                        <![CDATA[A |NodeParser| needs to be initialized with a |Parser|
object. If this method is to be overloaded then make sure
that it only accepts one parameter: ``parser``. This method
is used by |Parser| and it calls it with itself as the
parameter.]]>
                    </doc>
                </function>
            </method_block>
        </class>
        <class name="EntityNP">
            <bases>
                <base name="lexor.core.parser.NodeParser"/>
            </bases>
            <mro>
                <class name="lexor-lang_lexor_parser_default_entity.EntityNP"/>
                <class name="lexor.core.parser.NodeParser"/>
                <class name="__builtin__.object"/>
            </mro>
            <doc>
                <![CDATA[Processes special characters. This parser should be called
only after all the other processors have attempted to parse.]]>
            </doc>
            <method_block from="lexor-lang_lexor_parser_default_entity.EntityNP">
                <function name="_handle_escape">
                    <argspec varargs="None" keywords="None">
                        <args>
                            <arg name="self"/>
                            <arg name="parser"/>
                            <arg name="caret"/>
                        </args>
                    </argspec>
                    <doc>
                        <![CDATA[Helper function for make_node. ]]>
                    </doc>
                </function>
                <function name="_handle_lt">
                    <argspec varargs="None" keywords="None">
                        <args>
                            <arg name="self"/>
                            <arg name="parser"/>
                            <arg name="caret"/>
                        </args>
                    </argspec>
                    <doc>
                        <![CDATA[Helper function for make_node. ]]>
                    </doc>
                </function>
                <function name="make_node">
                    <argspec varargs="None" keywords="None">
                        <args>
                            <arg name="self"/>
                        </args>
                    </argspec>
                </function>
            </method_block>
            <method_block from="lexor.core.parser.NodeParser">
                <function name="__init__">
                    <argspec varargs="None" keywords="None">
                        <args>
                            <arg name="self"/>
                            <arg name="parser"/>
                        </args>
                    </argspec>
                    <doc>
                        <![CDATA[A |NodeParser| needs to be initialized with a |Parser|
object. If this method is to be overloaded then make sure
that it only accepts one parameter: ``parser``. This method
is used by |Parser| and it calls it with itself as the
parameter.]]>
                    </doc>
                </function>
                <function name="close">
                    <argspec varargs="None" keywords="None">
                        <args>
                            <arg name="self"/>
                            <arg name="_"/>
                        </args>
                    </argspec>
                    <doc>
                        <![CDATA[This method needs to be overloaded if the node parser
returns a |Node| with the :meth:`make_node` method.

This method will not get called if :meth:`make_node` returned
a |Node| inside a ``list``. The close function takes as input
the node object that :meth:`make_node` returned and it should
decide if the node can be closed or not. If it is indeed time
to close the node then return a ``list`` with the position
where the node is being closed, otherwise return ``None``.

If this method is not overloaded then a
``NotImplementedError`` exception will be raised.]]>
                    </doc>
                </function>
                <function name="make_node">
                    <argspec varargs="None" keywords="None">
                        <args>
                            <arg name="self"/>
                        </args>
                    </argspec>
                </function>
                <function name="msg">
                    <argspec varargs="None" keywords="None">
                        <args>
                            <arg name="self"/>
                            <arg name="code"/>
                            <arg name="pos"/>
                            <arg name="arg" default="None"/>
                            <arg name="uri" default="None"/>
                        </args>
                    </argspec>
                    <doc>
                        <![CDATA[Send a message to the parser by providing one of the error
codes defined in the style as well as the position where the
error took place. The position has the form of a list
containing the line and column number. Some error codes may
provide arguments, this can be passed to `arg`. In case the
error occurred somewhere not in the current document, perhaps
in a string, then you may provide a new `uri` to denote the
location.]]>
                    </doc>
                </function>
            </method_block>
            <member_block from="lexor.core.parser.NodeParser">
                <member name="__weakref__"/>
            </member_block>
            <method_block from="__builtin__.object">
                <function name="__init__">
                    <argspec varargs="None" keywords="None">
                        <args>
                            <arg name="self"/>
                            <arg name="parser"/>
                        </args>
                    </argspec>
                    <doc>
                        <![CDATA[A |NodeParser| needs to be initialized with a |Parser|
object. If this method is to be overloaded then make sure
that it only accepts one parameter: ``parser``. This method
is used by |Parser| and it calls it with itself as the
parameter.]]>
                    </doc>
                </function>
            </method_block>
        </class>
    </classes>
    <functions/>
    <data>
        <data name="RE">
            <![CDATA[<_sre.SRE_Pattern object at 0x10669b258>]]>
        </data>
        <data name="MSG">
            <![CDATA[{'E100': 'ignoring stray end tag `{0}`'}]]>
        </data>
        <data name="MSG_EXPLANATION">
            <![CDATA[['\n    - Stray end tags are common when writing html tags. If you wish\n      to display the stray tag then you should escape the components\n      of the stray tag or wrap with backticks.\n\n    Okay:\n        This is a stray tag: \\</p>\n\n    Okay:\n        This is an example of a stray tag `</p>`\n\n    E100: This is a stray tag: </p>\n']]]>
        </data>
    </data>
    <imports>
        <module fullname="re" name="re"/>
        <other fullname="lexor.core.elements.Text" type="type" name="Text"/>
        <other fullname="lexor.core.parser.NodeParser" type="type" name="NodeParser"/>
        <other fullname="lexor.core.elements.Entity" type="type" name="Entity"/>
        <other fullname="lexor.core.elements.Void" type="type" name="Void"/>
    </imports>
</module>
<module name="lexor-lang_lexor_parser_default_cdata">
    <doc>
        <![CDATA[LEXOR: CDATA NodeParser

`CData` nodes are enclosed within `<![CDATA[` and `]]]]><![CDATA[>`. These type
of nodes are useful because no parsing takes place inside the
content. The only restriction involved with these nodes is that the
character sequence `]]]]><![CDATA[>` must not appear in the content.

In case there is a need to write `]]]]><![CDATA[>` inside the character data then
you have to split the content into two `CData` nodes:

The correct way to write the following

    <![CDATA[Cannot have `]]]]><![CDATA[>` inside.]]]]><![CDATA[>

is

    <![CDATA[Cannot have `]]]]]]><![CDATA[><![CDATA[>` inside.]]]]><![CDATA[>

]]>
    </doc>
    <classes>
        <class name="CDataNP">
            <bases>
                <base name="lexor.core.parser.NodeParser"/>
            </bases>
            <mro>
                <class name="lexor-lang_lexor_parser_default_cdata.CDataNP"/>
                <class name="lexor.core.parser.NodeParser"/>
                <class name="__builtin__.object"/>
            </mro>
            <doc>
                <![CDATA[Retrives the data enclosed within `<![CDATA[` and `]]]]><![CDATA[>` and
returns a `CData` node. ]]>
            </doc>
            <method_block from="lexor-lang_lexor_parser_default_cdata.CDataNP">
                <function name="make_node">
                    <argspec varargs="None" keywords="None">
                        <args>
                            <arg name="self"/>
                        </args>
                    </argspec>
                </function>
            </method_block>
            <method_block from="lexor.core.parser.NodeParser">
                <function name="__init__">
                    <argspec varargs="None" keywords="None">
                        <args>
                            <arg name="self"/>
                            <arg name="parser"/>
                        </args>
                    </argspec>
                    <doc>
                        <![CDATA[A |NodeParser| needs to be initialized with a |Parser|
object. If this method is to be overloaded then make sure
that it only accepts one parameter: ``parser``. This method
is used by |Parser| and it calls it with itself as the
parameter.]]>
                    </doc>
                </function>
                <function name="close">
                    <argspec varargs="None" keywords="None">
                        <args>
                            <arg name="self"/>
                            <arg name="_"/>
                        </args>
                    </argspec>
                    <doc>
                        <![CDATA[This method needs to be overloaded if the node parser
returns a |Node| with the :meth:`make_node` method.

This method will not get called if :meth:`make_node` returned
a |Node| inside a ``list``. The close function takes as input
the node object that :meth:`make_node` returned and it should
decide if the node can be closed or not. If it is indeed time
to close the node then return a ``list`` with the position
where the node is being closed, otherwise return ``None``.

If this method is not overloaded then a
``NotImplementedError`` exception will be raised.]]>
                    </doc>
                </function>
                <function name="make_node">
                    <argspec varargs="None" keywords="None">
                        <args>
                            <arg name="self"/>
                        </args>
                    </argspec>
                </function>
                <function name="msg">
                    <argspec varargs="None" keywords="None">
                        <args>
                            <arg name="self"/>
                            <arg name="code"/>
                            <arg name="pos"/>
                            <arg name="arg" default="None"/>
                            <arg name="uri" default="None"/>
                        </args>
                    </argspec>
                    <doc>
                        <![CDATA[Send a message to the parser by providing one of the error
codes defined in the style as well as the position where the
error took place. The position has the form of a list
containing the line and column number. Some error codes may
provide arguments, this can be passed to `arg`. In case the
error occurred somewhere not in the current document, perhaps
in a string, then you may provide a new `uri` to denote the
location.]]>
                    </doc>
                </function>
            </method_block>
            <member_block from="lexor.core.parser.NodeParser">
                <member name="__weakref__"/>
            </member_block>
            <method_block from="__builtin__.object">
                <function name="__init__">
                    <argspec varargs="None" keywords="None">
                        <args>
                            <arg name="self"/>
                            <arg name="parser"/>
                        </args>
                    </argspec>
                    <doc>
                        <![CDATA[A |NodeParser| needs to be initialized with a |Parser|
object. If this method is to be overloaded then make sure
that it only accepts one parameter: ``parser``. This method
is used by |Parser| and it calls it with itself as the
parameter.]]>
                    </doc>
                </function>
            </method_block>
        </class>
    </classes>
    <functions/>
    <data>
        <data name="MSG">
            <![CDATA[{'E100': '`]]]]><![CDATA[>` not found'}]]>
        </data>
        <data name="MSG_EXPLANATION">
            <![CDATA[['\n    - The terminating character sequence for the `CData` node was not\n      found.\n\n    Okay: <![CDATA[We can write a < b and M&Ms.]]]]><![CDATA[>\n\n    E100: <![CDATA[We can write a < b and M&Ms.\n']]]>
        </data>
    </data>
    <imports>
        <other fullname="lexor.core.parser.NodeParser" type="type" name="NodeParser"/>
        <other fullname="lexor.core.elements.CData" type="type" name="CData"/>
    </imports>
</module>
<module name="lexor-lang_lexor_parser_default_pi">
    <doc>
        <![CDATA[LEXOR: PI NodeParser

Same as the HTML processing instruction. With the addition of
the following syntax:

    %%?PITarget PIContent%%

This means that the content cannot contain the sequence `%%`

]]>
    </doc>
    <classes>
        <class name="ProcessingInstructionNP">
            <bases>
                <base name="lexor.core.parser.NodeParser"/>
            </bases>
            <mro>
                <class name="lexor-lang_lexor_parser_default_pi.ProcessingInstructionNP"/>
                <class name="lexor.core.parser.NodeParser"/>
                <class name="__builtin__.object"/>
            </mro>
            <doc>
                <![CDATA[Parses content enclosed within `<?PITarget` and `?>` or
`%%?PITarget` and `%%`. Note that the target of the
`ProcessingInstruction` object that it returns has `?`
preappended to it. ]]>
            </doc>
            <method_block from="lexor-lang_lexor_parser_default_pi.ProcessingInstructionNP">
                <function name="make_node">
                    <argspec varargs="None" keywords="None">
                        <args>
                            <arg name="self"/>
                        </args>
                    </argspec>
                    <doc>
                        <![CDATA[Returns node if the parsers caret is not position at the
sequence `'<?'` or `'%%?'`. If it is found it returns a
`ProcessingInstruction` node containing all the text found
till the sequence `'?>'` or `'%%'` is found. If it is not
found a warning is issued and the parser caret is updated to
be at the end of the text that is currently begin parsed.

NOTE: A valid processing instruction is of the form

    <?PITarget* or %%?PITarget*

where `*` is a space character (this includes tabs and new
lines).]]>
                    </doc>
                </function>
            </method_block>
            <method_block from="lexor.core.parser.NodeParser">
                <function name="__init__">
                    <argspec varargs="None" keywords="None">
                        <args>
                            <arg name="self"/>
                            <arg name="parser"/>
                        </args>
                    </argspec>
                    <doc>
                        <![CDATA[A |NodeParser| needs to be initialized with a |Parser|
object. If this method is to be overloaded then make sure
that it only accepts one parameter: ``parser``. This method
is used by |Parser| and it calls it with itself as the
parameter.]]>
                    </doc>
                </function>
                <function name="close">
                    <argspec varargs="None" keywords="None">
                        <args>
                            <arg name="self"/>
                            <arg name="_"/>
                        </args>
                    </argspec>
                    <doc>
                        <![CDATA[This method needs to be overloaded if the node parser
returns a |Node| with the :meth:`make_node` method.

This method will not get called if :meth:`make_node` returned
a |Node| inside a ``list``. The close function takes as input
the node object that :meth:`make_node` returned and it should
decide if the node can be closed or not. If it is indeed time
to close the node then return a ``list`` with the position
where the node is being closed, otherwise return ``None``.

If this method is not overloaded then a
``NotImplementedError`` exception will be raised.]]>
                    </doc>
                </function>
                <function name="make_node">
                    <argspec varargs="None" keywords="None">
                        <args>
                            <arg name="self"/>
                        </args>
                    </argspec>
                    <doc>
                        <![CDATA[Returns node if the parsers caret is not position at the
sequence `'<?'` or `'%%?'`. If it is found it returns a
`ProcessingInstruction` node containing all the text found
till the sequence `'?>'` or `'%%'` is found. If it is not
found a warning is issued and the parser caret is updated to
be at the end of the text that is currently begin parsed.

NOTE: A valid processing instruction is of the form

    <?PITarget* or %%?PITarget*

where `*` is a space character (this includes tabs and new
lines).]]>
                    </doc>
                </function>
                <function name="msg">
                    <argspec varargs="None" keywords="None">
                        <args>
                            <arg name="self"/>
                            <arg name="code"/>
                            <arg name="pos"/>
                            <arg name="arg" default="None"/>
                            <arg name="uri" default="None"/>
                        </args>
                    </argspec>
                    <doc>
                        <![CDATA[Send a message to the parser by providing one of the error
codes defined in the style as well as the position where the
error took place. The position has the form of a list
containing the line and column number. Some error codes may
provide arguments, this can be passed to `arg`. In case the
error occurred somewhere not in the current document, perhaps
in a string, then you may provide a new `uri` to denote the
location.]]>
                    </doc>
                </function>
            </method_block>
            <member_block from="lexor.core.parser.NodeParser">
                <member name="__weakref__"/>
            </member_block>
            <method_block from="__builtin__.object">
                <function name="__init__">
                    <argspec varargs="None" keywords="None">
                        <args>
                            <arg name="self"/>
                            <arg name="parser"/>
                        </args>
                    </argspec>
                    <doc>
                        <![CDATA[A |NodeParser| needs to be initialized with a |Parser|
object. If this method is to be overloaded then make sure
that it only accepts one parameter: ``parser``. This method
is used by |Parser| and it calls it with itself as the
parameter.]]>
                    </doc>
                </function>
            </method_block>
        </class>
    </classes>
    <functions/>
    <data>
        <data name="RE">
            <![CDATA[<_sre.SRE_Pattern object at 0x1066ce4c8>]]>
        </data>
        <data name="MSG">
            <![CDATA[{'E102': '`%%{0}` was started but `%%` was not found', 'E100': 'ignoring processing instruction', 'E101': '`<{0}` was started but `?>` was not found'}]]>
        </data>
        <data name="MSG_EXPLANATION">
            <![CDATA[["\n    - A processing instruction must have a target and must be\n      enclosed within `<?` and `?>`.\n\n    - If there is no space following the target of the processing\n      instruction, that is, if the file ends abrutly, then the\n      processing instruction will be ignored.\n\n    Okay: <?php echo '<p>Hello World</p>'; ?>\n    Okay: %%?python print '<p>Hello World</p>' %%\n\n    E100: <?php\n    E101: <?php echo '<p>Hello World</p>';\n    E102: %%?python print '<p>Hello World</p>'\n"]]]>
        </data>
    </data>
    <imports>
        <module fullname="re" name="re"/>
        <other fullname="lexor.core.elements.ProcessingInstruction" type="type" name="ProcessingInstruction"/>
        <other fullname="lexor.core.elements.Text" type="type" name="Text"/>
        <other fullname="lexor.core.parser.NodeParser" type="type" name="NodeParser"/>
    </imports>
</module>
<module name="lexor-lang_lexor_parser_default_quote">
    <doc>
        <![CDATA[LEXOR: QUOTE NodeParser

Detetects quoted elements.

]]>
    </doc>
    <classes>
        <class name="QuoteNP">
            <bases>
                <base name="lexor.core.parser.NodeParser"/>
            </bases>
            <mro>
                <class name="lexor-lang_lexor_parser_default_quote.QuoteNP"/>
                <class name="lexor.core.parser.NodeParser"/>
                <class name="__builtin__.object"/>
            </mro>
            <doc>
                <![CDATA[Looks for quotes. ]]>
            </doc>
            <method_block from="lexor-lang_lexor_parser_default_quote.QuoteNP">
                <function name="close">
                    <argspec varargs="None" keywords="None">
                        <args>
                            <arg name="self"/>
                            <arg name="node"/>
                        </args>
                    </argspec>
                </function>
                <function name="make_node">
                    <argspec varargs="None" keywords="None">
                        <args>
                            <arg name="self"/>
                        </args>
                    </argspec>
                </function>
            </method_block>
            <method_block from="lexor.core.parser.NodeParser">
                <function name="__init__">
                    <argspec varargs="None" keywords="None">
                        <args>
                            <arg name="self"/>
                            <arg name="parser"/>
                        </args>
                    </argspec>
                    <doc>
                        <![CDATA[A |NodeParser| needs to be initialized with a |Parser|
object. If this method is to be overloaded then make sure
that it only accepts one parameter: ``parser``. This method
is used by |Parser| and it calls it with itself as the
parameter.]]>
                    </doc>
                </function>
                <function name="close">
                    <argspec varargs="None" keywords="None">
                        <args>
                            <arg name="self"/>
                            <arg name="node"/>
                        </args>
                    </argspec>
                </function>
                <function name="make_node">
                    <argspec varargs="None" keywords="None">
                        <args>
                            <arg name="self"/>
                        </args>
                    </argspec>
                </function>
                <function name="msg">
                    <argspec varargs="None" keywords="None">
                        <args>
                            <arg name="self"/>
                            <arg name="code"/>
                            <arg name="pos"/>
                            <arg name="arg" default="None"/>
                            <arg name="uri" default="None"/>
                        </args>
                    </argspec>
                    <doc>
                        <![CDATA[Send a message to the parser by providing one of the error
codes defined in the style as well as the position where the
error took place. The position has the form of a list
containing the line and column number. Some error codes may
provide arguments, this can be passed to `arg`. In case the
error occurred somewhere not in the current document, perhaps
in a string, then you may provide a new `uri` to denote the
location.]]>
                    </doc>
                </function>
            </method_block>
            <member_block from="lexor.core.parser.NodeParser">
                <member name="__weakref__"/>
            </member_block>
            <method_block from="__builtin__.object">
                <function name="__init__">
                    <argspec varargs="None" keywords="None">
                        <args>
                            <arg name="self"/>
                            <arg name="parser"/>
                        </args>
                    </argspec>
                    <doc>
                        <![CDATA[A |NodeParser| needs to be initialized with a |Parser|
object. If this method is to be overloaded then make sure
that it only accepts one parameter: ``parser``. This method
is used by |Parser| and it calls it with itself as the
parameter.]]>
                    </doc>
                </function>
            </method_block>
        </class>
    </classes>
    <functions/>
    <data>
        <data name="EMPTY">
            <![CDATA[' \t\n\r\x0c\x0b']]>
        </data>
    </data>
    <imports>
        <other fullname="lexor.core.elements.Element" type="type" name="Element"/>
        <other fullname="lexor.core.elements.Entity" type="type" name="Entity"/>
        <other fullname="lexor.core.parser.NodeParser" type="type" name="NodeParser"/>
    </imports>
</module>
<module name="lexor-lang_lexor_parser_default_header">
    <doc>
        <![CDATA[LEXOR: HEADER NodeParser

Lexor supports two types of headers: setext and atx.

]]>
    </doc>
    <classes>
        <class name="AtxHeaderNP">
            <bases>
                <base name="lexor.core.parser.NodeParser"/>
            </bases>
            <mro>
                <class name="lexor-lang_lexor_parser_default_header.AtxHeaderNP"/>
                <class name="lexor.core.parser.NodeParser"/>
                <class name="__builtin__.object"/>
            </mro>
            <doc>
                <![CDATA[Parses header elements in the atx style. ]]>
            </doc>
            <method_block from="lexor-lang_lexor_parser_default_header.AtxHeaderNP">
                <function name="close">
                    <argspec varargs="None" keywords="None">
                        <args>
                            <arg name="self"/>
                            <arg name="node"/>
                        </args>
                    </argspec>
                </function>
                <function name="make_node">
                    <argspec varargs="None" keywords="None">
                        <args>
                            <arg name="self"/>
                        </args>
                    </argspec>
                </function>
            </method_block>
            <method_block from="lexor.core.parser.NodeParser">
                <function name="__init__">
                    <argspec varargs="None" keywords="None">
                        <args>
                            <arg name="self"/>
                            <arg name="parser"/>
                        </args>
                    </argspec>
                    <doc>
                        <![CDATA[A |NodeParser| needs to be initialized with a |Parser|
object. If this method is to be overloaded then make sure
that it only accepts one parameter: ``parser``. This method
is used by |Parser| and it calls it with itself as the
parameter.]]>
                    </doc>
                </function>
                <function name="close">
                    <argspec varargs="None" keywords="None">
                        <args>
                            <arg name="self"/>
                            <arg name="node"/>
                        </args>
                    </argspec>
                </function>
                <function name="make_node">
                    <argspec varargs="None" keywords="None">
                        <args>
                            <arg name="self"/>
                        </args>
                    </argspec>
                </function>
                <function name="msg">
                    <argspec varargs="None" keywords="None">
                        <args>
                            <arg name="self"/>
                            <arg name="code"/>
                            <arg name="pos"/>
                            <arg name="arg" default="None"/>
                            <arg name="uri" default="None"/>
                        </args>
                    </argspec>
                    <doc>
                        <![CDATA[Send a message to the parser by providing one of the error
codes defined in the style as well as the position where the
error took place. The position has the form of a list
containing the line and column number. Some error codes may
provide arguments, this can be passed to `arg`. In case the
error occurred somewhere not in the current document, perhaps
in a string, then you may provide a new `uri` to denote the
location.]]>
                    </doc>
                </function>
            </method_block>
            <member_block from="lexor.core.parser.NodeParser">
                <member name="__weakref__"/>
            </member_block>
            <method_block from="__builtin__.object">
                <function name="__init__">
                    <argspec varargs="None" keywords="None">
                        <args>
                            <arg name="self"/>
                            <arg name="parser"/>
                        </args>
                    </argspec>
                    <doc>
                        <![CDATA[A |NodeParser| needs to be initialized with a |Parser|
object. If this method is to be overloaded then make sure
that it only accepts one parameter: ``parser``. This method
is used by |Parser| and it calls it with itself as the
parameter.]]>
                    </doc>
                </function>
            </method_block>
        </class>
        <class name="SetextHeaderNP">
            <bases>
                <base name="lexor.core.parser.NodeParser"/>
            </bases>
            <mro>
                <class name="lexor-lang_lexor_parser_default_header.SetextHeaderNP"/>
                <class name="lexor.core.parser.NodeParser"/>
                <class name="__builtin__.object"/>
            </mro>
            <doc>
                <![CDATA[Parses header elements. ]]>
            </doc>
            <method_block from="lexor-lang_lexor_parser_default_header.SetextHeaderNP">
                <function name="close">
                    <argspec varargs="None" keywords="None">
                        <args>
                            <arg name="self"/>
                            <arg name="node"/>
                        </args>
                    </argspec>
                    <doc>
                        <![CDATA[Returns the position where the element was closed. ]]>
                    </doc>
                </function>
                <function name="make_node">
                    <argspec varargs="None" keywords="None">
                        <args>
                            <arg name="self"/>
                        </args>
                    </argspec>
                    <doc>
                        <![CDATA[Returns a header element.]]>
                    </doc>
                </function>
            </method_block>
            <method_block from="lexor.core.parser.NodeParser">
                <function name="__init__">
                    <argspec varargs="None" keywords="None">
                        <args>
                            <arg name="self"/>
                            <arg name="parser"/>
                        </args>
                    </argspec>
                    <doc>
                        <![CDATA[A |NodeParser| needs to be initialized with a |Parser|
object. If this method is to be overloaded then make sure
that it only accepts one parameter: ``parser``. This method
is used by |Parser| and it calls it with itself as the
parameter.]]>
                    </doc>
                </function>
                <function name="close">
                    <argspec varargs="None" keywords="None">
                        <args>
                            <arg name="self"/>
                            <arg name="node"/>
                        </args>
                    </argspec>
                    <doc>
                        <![CDATA[Returns the position where the element was closed. ]]>
                    </doc>
                </function>
                <function name="make_node">
                    <argspec varargs="None" keywords="None">
                        <args>
                            <arg name="self"/>
                        </args>
                    </argspec>
                    <doc>
                        <![CDATA[Returns a header element.]]>
                    </doc>
                </function>
                <function name="msg">
                    <argspec varargs="None" keywords="None">
                        <args>
                            <arg name="self"/>
                            <arg name="code"/>
                            <arg name="pos"/>
                            <arg name="arg" default="None"/>
                            <arg name="uri" default="None"/>
                        </args>
                    </argspec>
                    <doc>
                        <![CDATA[Send a message to the parser by providing one of the error
codes defined in the style as well as the position where the
error took place. The position has the form of a list
containing the line and column number. Some error codes may
provide arguments, this can be passed to `arg`. In case the
error occurred somewhere not in the current document, perhaps
in a string, then you may provide a new `uri` to denote the
location.]]>
                    </doc>
                </function>
            </method_block>
            <member_block from="lexor.core.parser.NodeParser">
                <member name="__weakref__"/>
            </member_block>
            <method_block from="__builtin__.object">
                <function name="__init__">
                    <argspec varargs="None" keywords="None">
                        <args>
                            <arg name="self"/>
                            <arg name="parser"/>
                        </args>
                    </argspec>
                    <doc>
                        <![CDATA[A |NodeParser| needs to be initialized with a |Parser|
object. If this method is to be overloaded then make sure
that it only accepts one parameter: ``parser``. This method
is used by |Parser| and it calls it with itself as the
parameter.]]>
                    </doc>
                </function>
            </method_block>
        </class>
    </classes>
    <functions/>
    <data>
        <data name="SETEXT_RE">
            <![CDATA[<_sre.SRE_Pattern object at 0x10662f970>]]>
        </data>
    </data>
    <imports>
        <module fullname="re" name="re"/>
        <other fullname="lexor.core.elements.Element" type="type" name="Element"/>
        <other fullname="lexor.core.parser.NodeParser" type="type" name="NodeParser"/>
    </imports>
</module>
<module name="lexor-lang_lexor_parser_default_reference">
    <doc>
        <![CDATA[LEXOR: REFERENCE NodeParser

]]>
    </doc>
    <classes>
        <class name="ReferenceInlineNP">
            <bases>
                <base name="lexor.core.parser.NodeParser"/>
            </bases>
            <mro>
                <class name="lexor-lang_lexor_parser_default_reference.ReferenceInlineNP"/>
                <class name="lexor.core.parser.NodeParser"/>
                <class name="__builtin__.object"/>
            </mro>
            <doc>
                <![CDATA[Parses inline references.

![alt text](url) or ![alt text](url "title")
[text](url) or [text](url "title")

![alt text][2] or ![alt text] [2]
[Google][3] or [Google] [3]

![alt text]
[Google]]]>
            </doc>
            <method_block from="lexor-lang_lexor_parser_default_reference.ReferenceInlineNP">
                <function name="close">
                    <argspec varargs="None" keywords="None">
                        <args>
                            <arg name="self"/>
                            <arg name="node"/>
                        </args>
                    </argspec>
                </function>
                <function name="get_inline_info">
                    <argspec varargs="None" keywords="None">
                        <args>
                            <arg name="self"/>
                            <arg name="parser"/>
                            <arg name="node"/>
                        </args>
                    </argspec>
                    <doc>
                        <![CDATA[Assumes that the parser is positioned at (]]>
                    </doc>
                </function>
                <function name="make_node">
                    <argspec varargs="None" keywords="None">
                        <args>
                            <arg name="self"/>
                        </args>
                    </argspec>
                </function>
            </method_block>
            <method_block from="lexor.core.parser.NodeParser">
                <function name="__init__">
                    <argspec varargs="None" keywords="None">
                        <args>
                            <arg name="self"/>
                            <arg name="parser"/>
                        </args>
                    </argspec>
                    <doc>
                        <![CDATA[A |NodeParser| needs to be initialized with a |Parser|
object. If this method is to be overloaded then make sure
that it only accepts one parameter: ``parser``. This method
is used by |Parser| and it calls it with itself as the
parameter.]]>
                    </doc>
                </function>
                <function name="close">
                    <argspec varargs="None" keywords="None">
                        <args>
                            <arg name="self"/>
                            <arg name="node"/>
                        </args>
                    </argspec>
                </function>
                <function name="make_node">
                    <argspec varargs="None" keywords="None">
                        <args>
                            <arg name="self"/>
                        </args>
                    </argspec>
                </function>
                <function name="msg">
                    <argspec varargs="None" keywords="None">
                        <args>
                            <arg name="self"/>
                            <arg name="code"/>
                            <arg name="pos"/>
                            <arg name="arg" default="None"/>
                            <arg name="uri" default="None"/>
                        </args>
                    </argspec>
                    <doc>
                        <![CDATA[Send a message to the parser by providing one of the error
codes defined in the style as well as the position where the
error took place. The position has the form of a list
containing the line and column number. Some error codes may
provide arguments, this can be passed to `arg`. In case the
error occurred somewhere not in the current document, perhaps
in a string, then you may provide a new `uri` to denote the
location.]]>
                    </doc>
                </function>
            </method_block>
            <member_block from="lexor.core.parser.NodeParser">
                <member name="__weakref__"/>
            </member_block>
            <method_block from="__builtin__.object">
                <function name="__init__">
                    <argspec varargs="None" keywords="None">
                        <args>
                            <arg name="self"/>
                            <arg name="parser"/>
                        </args>
                    </argspec>
                    <doc>
                        <![CDATA[A |NodeParser| needs to be initialized with a |Parser|
object. If this method is to be overloaded then make sure
that it only accepts one parameter: ``parser``. This method
is used by |Parser| and it calls it with itself as the
parameter.]]>
                    </doc>
                </function>
            </method_block>
        </class>
        <class name="ReferenceBlockNP">
            <bases>
                <base name="lexor.core.parser.NodeParser"/>
            </bases>
            <mro>
                <class name="lexor-lang_lexor_parser_default_reference.ReferenceBlockNP"/>
                <class name="lexor.core.parser.NodeParser"/>
                <class name="__builtin__.object"/>
            </mro>
            <doc>
                <![CDATA[Parses reference blocks. These are the following ways to
write these blocks:

    [ref]: url "title" Attributes

    [ref]: url Attributes

    [ref]: url Attributes
           "title"

    [ref]: url "title" { Attributes }

    {att_ref}: Attributes

    {att_ref}: { Attributes }

Note that this node parser will get activated if it matches
`[ref]:` or `{att_ref}:`. If your line will start with this
then escape `[` or `{`.

Returns a node with one of the following names:

    'address_reference'
    'attribute_reference']]>
            </doc>
            <method_block from="lexor-lang_lexor_parser_default_reference.ReferenceBlockNP">
                <function name="is_block_reference">
                    <argspec varargs="None" keywords="None">
                        <args>
                            <arg name="self"/>
                            <arg name="parser"/>
                        </args>
                    </argspec>
                    <doc>
                        <![CDATA[Checks to see if the parser is placed at a block
reference. If it is, then it returns the node that will hold
the information. The returned node will have two properties:
pos and line_end. Make sure to delete them before returning
the node. ]]>
                    </doc>
                </function>
                <function name="is_title">
                    <argspec varargs="None" keywords="None">
                        <args>
                            <arg name="self"/>
                            <arg name="parser"/>
                            <arg name="line_end" default="None"/>
                        </args>
                    </argspec>
                    <doc>
                        <![CDATA[Return a string enclosed by quotes (single or double) and
the index where it the parser should continue reading. Return
none if there is no title. The optional argument should be
the index until the parser is allowed to look for the title.
By default it looks till the end of the line. ]]>
                    </doc>
                </function>
                <function name="make_node">
                    <argspec varargs="None" keywords="None">
                        <args>
                            <arg name="self"/>
                        </args>
                    </argspec>
                </function>
                <function name="update_link_ref">
                    <argspec varargs="None" keywords="None">
                        <args>
                            <arg name="self"/>
                            <arg name="parser"/>
                            <arg name="node"/>
                        </args>
                    </argspec>
                    <doc>
                        <![CDATA[parse the rest of the line of the link reference. ]]>
                    </doc>
                </function>
            </method_block>
            <method_block from="lexor.core.parser.NodeParser">
                <function name="__init__">
                    <argspec varargs="None" keywords="None">
                        <args>
                            <arg name="self"/>
                            <arg name="parser"/>
                        </args>
                    </argspec>
                    <doc>
                        <![CDATA[A |NodeParser| needs to be initialized with a |Parser|
object. If this method is to be overloaded then make sure
that it only accepts one parameter: ``parser``. This method
is used by |Parser| and it calls it with itself as the
parameter.]]>
                    </doc>
                </function>
                <function name="close">
                    <argspec varargs="None" keywords="None">
                        <args>
                            <arg name="self"/>
                            <arg name="_"/>
                        </args>
                    </argspec>
                    <doc>
                        <![CDATA[This method needs to be overloaded if the node parser
returns a |Node| with the :meth:`make_node` method.

This method will not get called if :meth:`make_node` returned
a |Node| inside a ``list``. The close function takes as input
the node object that :meth:`make_node` returned and it should
decide if the node can be closed or not. If it is indeed time
to close the node then return a ``list`` with the position
where the node is being closed, otherwise return ``None``.

If this method is not overloaded then a
``NotImplementedError`` exception will be raised.]]>
                    </doc>
                </function>
                <function name="make_node">
                    <argspec varargs="None" keywords="None">
                        <args>
                            <arg name="self"/>
                        </args>
                    </argspec>
                </function>
                <function name="msg">
                    <argspec varargs="None" keywords="None">
                        <args>
                            <arg name="self"/>
                            <arg name="code"/>
                            <arg name="pos"/>
                            <arg name="arg" default="None"/>
                            <arg name="uri" default="None"/>
                        </args>
                    </argspec>
                    <doc>
                        <![CDATA[Send a message to the parser by providing one of the error
codes defined in the style as well as the position where the
error took place. The position has the form of a list
containing the line and column number. Some error codes may
provide arguments, this can be passed to `arg`. In case the
error occurred somewhere not in the current document, perhaps
in a string, then you may provide a new `uri` to denote the
location.]]>
                    </doc>
                </function>
            </method_block>
            <member_block from="lexor.core.parser.NodeParser">
                <member name="__weakref__"/>
            </member_block>
            <method_block from="__builtin__.object">
                <function name="__init__">
                    <argspec varargs="None" keywords="None">
                        <args>
                            <arg name="self"/>
                            <arg name="parser"/>
                        </args>
                    </argspec>
                    <doc>
                        <![CDATA[A |NodeParser| needs to be initialized with a |Parser|
object. If this method is to be overloaded then make sure
that it only accepts one parameter: ``parser``. This method
is used by |Parser| and it calls it with itself as the
parameter.]]>
                    </doc>
                </function>
            </method_block>
        </class>
    </classes>
    <functions>
        <function name="check_parity">
            <argspec varargs="None" keywords="None">
                <args>
                    <arg name="parser"/>
                    <arg name="index"/>
                </args>
            </argspec>
            <doc>
                <![CDATA[Returns the parity of '[]' and the index where it ends. ]]>
            </doc>
        </function>
        <function name="get_inline_id">
            <argspec varargs="None" keywords="None">
                <args>
                    <arg name="parser"/>
                    <arg name="node"/>
                </args>
            </argspec>
            <doc>
                <![CDATA[Assumes that the parser is positioned at '[']]>
            </doc>
        </function>
    </functions>
    <data>
        <data name="RE_NOSPACE">
            <![CDATA[<_sre.SRE_Pattern object at 0x1066ce618>]]>
        </data>
        <data name="MSG">
            <![CDATA[{'E102': 'possible reference title detected', 'E103': 'incomplete inline reference at {0}:{1:2}', 'E100': 'no newline at end of file', 'E101': 'invalid link reference'}]]>
        </data>
        <data name="MSG_EXPLANATION">
            <![CDATA[['\n    - The last line should have a newline.\n\n    Reports E100.\n\n', '\n    - When using link references you must provide the an address.\n      This can be a url or a local address.\n\n    - If you did not meant to provide a link reference then escape\n      `[`.\n\n    Okay:\n        [math_url]: http://www.mathematics.uh.edu/\n\n    E101:\n        [math_url]:\n\n', '\n    - Titles are allowed to be under the link reference. When this\n      is the case you may not write text right after it.\n\n    - If you did not meant to write a title then leave an empty line\n    after the reference to get rid of message E102.\n\n    Okay:\n        [math_url]: http://www.mathematics.uh.edu/\n                    "UH Math Website"\n\n    E102:\n        [math_url]: http://www.mathematics.uh.edu/\n                    "UH Math Website". No content allowed in this line.\n\n', "\n    - An inline reference was detected due to the opening of '(' but\n      its closing character ')' was not found. As a result, the inline\n      reference will not have a src or href attribute.\n\n    Okay:\n        This is a [link to google](http://google.com)\n\n    E103:\n        This is a [link to google](http://google.com\n\n"]]]>
        </data>
        <data name="RE_INLINE">
            <![CDATA[<_sre.SRE_Pattern object at 0x10669b480>]]>
        </data>
        <data name="RE">
            <![CDATA[<_sre.SRE_Pattern object at 0x106642750>]]>
        </data>
    </data>
    <imports>
        <module fullname="re" name="re"/>
        <other fullname="lexor.core.elements.Element" type="type" name="Element"/>
        <other fullname="lexor.core.elements.Void" type="type" name="Void"/>
        <other fullname="lexor.core.parser.NodeParser" type="type" name="NodeParser"/>
    </imports>
</module>
<module name="lexor-lang_lexor_parser_default_code">
    <doc>
        <![CDATA[LEXOR: CODE NodeParser

]]>
    </doc>
    <classes>
        <class name="CodeInlineNP">
            <bases>
                <base name="lexor.core.parser.NodeParser"/>
            </bases>
            <mro>
                <class name="lexor-lang_lexor_parser_default_code.CodeInlineNP"/>
                <class name="lexor.core.parser.NodeParser"/>
                <class name="__builtin__.object"/>
            </mro>
            <doc>
                <![CDATA[Obtain code enclosed by backticks. ]]>
            </doc>
            <method_block from="lexor-lang_lexor_parser_default_code.CodeInlineNP">
                <function name="make_node">
                    <argspec varargs="None" keywords="None">
                        <args>
                            <arg name="self"/>
                        </args>
                    </argspec>
                </function>
                <function name="obtain_content">
                    <argspec varargs="None" keywords="None">
                        <args>
                            <arg name="self"/>
                            <arg name="parser"/>
                            <arg name="index"/>
                            <arg name="end_index"/>
                            <arg name="count"/>
                        </args>
                    </argspec>
                    <doc>
                        <![CDATA[Check for a possible ambiguity and return the
content of the inline code node. ]]>
                    </doc>
                </function>
            </method_block>
            <method_block from="lexor.core.parser.NodeParser">
                <function name="__init__">
                    <argspec varargs="None" keywords="None">
                        <args>
                            <arg name="self"/>
                            <arg name="parser"/>
                        </args>
                    </argspec>
                    <doc>
                        <![CDATA[A |NodeParser| needs to be initialized with a |Parser|
object. If this method is to be overloaded then make sure
that it only accepts one parameter: ``parser``. This method
is used by |Parser| and it calls it with itself as the
parameter.]]>
                    </doc>
                </function>
                <function name="close">
                    <argspec varargs="None" keywords="None">
                        <args>
                            <arg name="self"/>
                            <arg name="_"/>
                        </args>
                    </argspec>
                    <doc>
                        <![CDATA[This method needs to be overloaded if the node parser
returns a |Node| with the :meth:`make_node` method.

This method will not get called if :meth:`make_node` returned
a |Node| inside a ``list``. The close function takes as input
the node object that :meth:`make_node` returned and it should
decide if the node can be closed or not. If it is indeed time
to close the node then return a ``list`` with the position
where the node is being closed, otherwise return ``None``.

If this method is not overloaded then a
``NotImplementedError`` exception will be raised.]]>
                    </doc>
                </function>
                <function name="make_node">
                    <argspec varargs="None" keywords="None">
                        <args>
                            <arg name="self"/>
                        </args>
                    </argspec>
                </function>
                <function name="msg">
                    <argspec varargs="None" keywords="None">
                        <args>
                            <arg name="self"/>
                            <arg name="code"/>
                            <arg name="pos"/>
                            <arg name="arg" default="None"/>
                            <arg name="uri" default="None"/>
                        </args>
                    </argspec>
                    <doc>
                        <![CDATA[Send a message to the parser by providing one of the error
codes defined in the style as well as the position where the
error took place. The position has the form of a list
containing the line and column number. Some error codes may
provide arguments, this can be passed to `arg`. In case the
error occurred somewhere not in the current document, perhaps
in a string, then you may provide a new `uri` to denote the
location.]]>
                    </doc>
                </function>
            </method_block>
            <member_block from="lexor.core.parser.NodeParser">
                <member name="__weakref__"/>
            </member_block>
            <method_block from="__builtin__.object">
                <function name="__init__">
                    <argspec varargs="None" keywords="None">
                        <args>
                            <arg name="self"/>
                            <arg name="parser"/>
                        </args>
                    </argspec>
                    <doc>
                        <![CDATA[A |NodeParser| needs to be initialized with a |Parser|
object. If this method is to be overloaded then make sure
that it only accepts one parameter: ``parser``. This method
is used by |Parser| and it calls it with itself as the
parameter.]]>
                    </doc>
                </function>
            </method_block>
        </class>
        <class name="CodeBlockNP">
            <bases>
                <base name="lexor.core.parser.NodeParser"/>
            </bases>
            <mro>
                <class name="lexor-lang_lexor_parser_default_code.CodeBlockNP"/>
                <class name="lexor.core.parser.NodeParser"/>
                <class name="__builtin__.object"/>
            </mro>
            <doc>
                <![CDATA[A code block is a block that stars with a line with 4 spaces
or the tab character. The block ends when the line does not start
with 4 spaces or a tab character.

You may also start a code block by writing a sequence of three
`~` at the beginning of the line, in this way there no
indentation will be required. The block ends with a row of `~` at
least as long as the starting row.

This returns a pre tag to work with Alex Gorbatchev's
[SyntaxHighlighter](http://alexgorbatchev.com/SyntaxHighlighter)

This function uses the code_hilite function which is a modified
body of code from Waylan Limberg. See the documentation on
code_hilite for more info.

Note that this does not replace the characters '<' and '&'. The
writer must convert these characters in the output.]]>
            </doc>
            <method_block from="lexor-lang_lexor_parser_default_code.CodeBlockNP">
                <function name="get_fenced_block">
                    <argspec varargs="None" keywords="None">
                        <args>
                            <arg name="self"/>
                            <arg name="match"/>
                        </args>
                    </argspec>
                    <doc>
                        <![CDATA[Parse a fenced block code. ]]>
                    </doc>
                </function>
                <function name="make_node">
                    <argspec varargs="None" keywords="None">
                        <args>
                            <arg name="self"/>
                        </args>
                    </argspec>
                </function>
            </method_block>
            <method_block from="lexor.core.parser.NodeParser">
                <function name="__init__">
                    <argspec varargs="None" keywords="None">
                        <args>
                            <arg name="self"/>
                            <arg name="parser"/>
                        </args>
                    </argspec>
                    <doc>
                        <![CDATA[A |NodeParser| needs to be initialized with a |Parser|
object. If this method is to be overloaded then make sure
that it only accepts one parameter: ``parser``. This method
is used by |Parser| and it calls it with itself as the
parameter.]]>
                    </doc>
                </function>
                <function name="close">
                    <argspec varargs="None" keywords="None">
                        <args>
                            <arg name="self"/>
                            <arg name="_"/>
                        </args>
                    </argspec>
                    <doc>
                        <![CDATA[This method needs to be overloaded if the node parser
returns a |Node| with the :meth:`make_node` method.

This method will not get called if :meth:`make_node` returned
a |Node| inside a ``list``. The close function takes as input
the node object that :meth:`make_node` returned and it should
decide if the node can be closed or not. If it is indeed time
to close the node then return a ``list`` with the position
where the node is being closed, otherwise return ``None``.

If this method is not overloaded then a
``NotImplementedError`` exception will be raised.]]>
                    </doc>
                </function>
                <function name="make_node">
                    <argspec varargs="None" keywords="None">
                        <args>
                            <arg name="self"/>
                        </args>
                    </argspec>
                </function>
                <function name="msg">
                    <argspec varargs="None" keywords="None">
                        <args>
                            <arg name="self"/>
                            <arg name="code"/>
                            <arg name="pos"/>
                            <arg name="arg" default="None"/>
                            <arg name="uri" default="None"/>
                        </args>
                    </argspec>
                    <doc>
                        <![CDATA[Send a message to the parser by providing one of the error
codes defined in the style as well as the position where the
error took place. The position has the form of a list
containing the line and column number. Some error codes may
provide arguments, this can be passed to `arg`. In case the
error occurred somewhere not in the current document, perhaps
in a string, then you may provide a new `uri` to denote the
location.]]>
                    </doc>
                </function>
            </method_block>
            <member_block from="lexor.core.parser.NodeParser">
                <member name="__weakref__"/>
            </member_block>
            <method_block from="__builtin__.object">
                <function name="__init__">
                    <argspec varargs="None" keywords="None">
                        <args>
                            <arg name="self"/>
                            <arg name="parser"/>
                        </args>
                    </argspec>
                    <doc>
                        <![CDATA[A |NodeParser| needs to be initialized with a |Parser|
object. If this method is to be overloaded then make sure
that it only accepts one parameter: ``parser``. This method
is used by |Parser| and it calls it with itself as the
parameter.]]>
                    </doc>
                </function>
            </method_block>
        </class>
    </classes>
    <functions>
        <function name="code_hilite">
            <argspec varargs="None" keywords="None">
                <args>
                    <arg name="line_one"/>
                    <arg name="node"/>
                </args>
            </argspec>
            <doc>
                <![CDATA[This function is a modification from CodeHilite.py created by
Waylan Limberg.

It determines the language of the code block from the first line
and whether said line should be removed or left in place. If the
shebang line contains a path (even a single /) then it is assumed
to be a real shebang line and left alone. However, if no path is
given (e.i.: #!python or :::python) then it is assumed to be a
mock shebang for language identifitation of a code fragment and
removed from the code block prior to processing for code
highlighting. When a mock shebang (e.i: #!python) is found, line
numbering is turned on. When colons are found in place of a
shebang (e.i.: :::python), line numbering is left off. More info
here:

http://packages.python.org/Markdown/extensions/code_hilite.html

In addition, the information on the first line will set the class
attribute of the node so that it may work with SyntaxHighlighter
developed by Alex Gorbatchev. More info here:

http://alexgorbatchev.com/SyntaxHighlighter

After the shebang line you may write more instructions that for
the syntaxHighliter. For instance:

#!/usr/bin/python first-line: 10; highlight: [2, 4, 6]

Everything after the first space will be appened to the class
attribute. For this reason there is no need to modify the
attribute list which can be declared in the first line.

#!/usr/bin/python highlight: [2, 4, 6] {#someid}

If you wish to overwrite the class attribute completely then you
may start with the following line:

:::{class="new"}

Note that doing so will also result in lexor giving you a warning
since you overwriting an attribute which has already been
declared.

The function returns either an empty list or a list with the first
line as its only element.]]>
            </doc>
        </function>
    </functions>
    <data>
        <data name="MSG">
            <![CDATA[{'E200': 'closing row of `{0}` or more `~` not found', 'E100': 'ambiguous inline code ends at {0}:{1:2}', 'E101': 'no more backticks after {0}:{1:2} to match'}]]>
        </data>
        <data name="MSG_EXPLANATION">
            <![CDATA[['\n    - Inline code can be marked up by surrounding it with backticks.\n      To use literal backticks, use two or more backticks as\n      delimiters.\n\n    - When inserting literal backticks you should use a space right\n      after the starting delimiter and one space right before the\n      closing delimiter. This rule is to avoid ambiguity.\n\n    Okay:\n        `a < b`\n\n    Okay:\n        Use backticks to markup code, e.g. `` `code` ``.\n\n    Okay:\n        This is a backtick: `` ` ``.\n\n    E100:\n        This is a backtick: `` ```.\n\n    E100:\n        This is a backtick: ``` ``.\n\n    E101:\n        This is a backtick: `````.\n', "\n    - Fenced code blocks start with 4 or more `~`. To close it you\n      must end the block with at least the number of `~` of the\n      starting row.\n\n    Okay:\n        ~~~~\n        print 'hello'\n        ~~~~\n\n    Okay:\n        ~~~~~~~\n        ~~~~\n        print 'hello'\n        ~~~~\n        ~~~~~~~\n\n    E200:\n        ~~~~~~~\n        ~~~~\n        print 'hello'\n        ~~~~\n        ~~~~~~\n"]]]>
        </data>
        <data name="LANG_RE">
            <![CDATA[<_sre.SRE_Pattern object at 0x1062ea6f0>]]>
        </data>
        <data name="FENCED">
            <![CDATA[<_sre.SRE_Pattern object at 0x1065e46f0>]]>
        </data>
    </data>
    <imports>
        <module fullname="re" name="re"/>
        <other fullname="lexor.core.elements.Element" type="type" name="Element"/>
        <other fullname="lexor.core.elements.Text" type="type" name="Text"/>
        <other fullname="lexor.core.parser.NodeParser" type="type" name="NodeParser"/>
    </imports>
</module>
<module name="lexor-lang_lexor_parser_default_element">
    <doc>
        <![CDATA[LEXOR: ELEMENT NodeParser

Handles all `Elements` in the form

    <tagname att1="val1" att2="val2">...</tagname>
    <tagname #id .class1>...</tagname>
    %%{tagname id="id" class="class1"}...%%
    %%{tagname #id .class1}...%%
    %%{#id .class1}...%%

If no tagname is given then it the name of the element defaults to
`span`.

]]>
    </doc>
    <classes>
        <class name="ElementNP">
            <bases>
                <base name="lexor.core.parser.NodeParser"/>
            </bases>
            <mro>
                <class name="lexor-lang_lexor_parser_default_element.ElementNP"/>
                <class name="lexor.core.parser.NodeParser"/>
                <class name="__builtin__.object"/>
            </mro>
            <doc>
                <![CDATA[Parses all the lexor elements. The following are equivalent
elements:

    <div id="id" class="class1">div content</div>
    <div #id .class1>div content</div>
    %%{div id="id" class="class1"}div content%%
    %%{div #id .class1}div content%%

The following form declares a `span` tag:

    %%{#id .class1}div content%%

This is using the default form of this new tag format. There are
cases when span elements are useful when formatting and we need
to either give them a class or id. The following is a an empty
span

    %%{}%%

The start tag is '%%{}' Inside the brackets we can put the
nametag and attributes. The tag ends when '%%' is encountered.
Using this form allows also to put the old html tag format as
well as the new one.

The rules of HTML apply here. For instance if you write a "p" tag
it and we encounter another "p" tag before its closing tag then
the first p tag will be closed.]]>
            </doc>
            <method_block from="lexor-lang_lexor_parser_default_element.ElementNP">
                <function name="close">
                    <argspec varargs="None" keywords="None">
                        <args>
                            <arg name="self"/>
                            <arg name="node"/>
                        </args>
                    </argspec>
                    <doc>
                        <![CDATA[Returns the position where the element was closed. ]]>
                    </doc>
                </function>
                <function name="get_attribute_list">
                    <argspec varargs="None" keywords="None">
                        <args>
                            <arg name="self"/>
                            <arg name="parser"/>
                            <arg name="node"/>
                            <arg name="start" default="{"/>
                            <arg name="end" default="}"/>
                        </args>
                    </argspec>
                    <doc>
                        <![CDATA[Attempts to get the attribute list at the current position
where the parser is reading. ]]>
                    </doc>
                </function>
                <function name="get_raw_text">
                    <argspec varargs="None" keywords="None">
                        <args>
                            <arg name="self"/>
                            <arg name="parser"/>
                            <arg name="tagname"/>
                            <arg name="pos"/>
                            <arg name="shift"/>
                        </args>
                    </argspec>
                    <doc>
                        <![CDATA[Return the data content of the RawText object and update
the caret. ]]>
                    </doc>
                </function>
                <function name="get_tagname">
                    <argspec varargs="None" keywords="None">
                        <args>
                            <arg name="self"/>
                            <arg name="parser"/>
                        </args>
                    </argspec>
                    <doc>
                        <![CDATA[If the parser is positioned at an element it will return
the tagname, otherwise it returns None. ]]>
                    </doc>
                </function>
                <function name="handle_id_ref">
                    <argspec varargs="None" keywords="None">
                        <args>
                            <arg name="self"/>
                            <arg name="parser"/>
                            <arg name="node"/>
                            <arg name="prop"/>
                            <arg name="prop_index"/>
                            <arg name="prop_type"/>
                        </args>
                    </argspec>
                    <doc>
                        <![CDATA[Handle the ID and Python references. ]]>
                    </doc>
                </function>
                <function name="is_done">
                    <argspec varargs="None" keywords="None">
                        <args>
                            <arg name="self"/>
                            <arg name="node"/>
                            <arg name="parser"/>
                            <arg name="caret"/>
                        </args>
                    </argspec>
                    <doc>
                        <![CDATA[Checks to see if the node should be closed. It returns one
of 3 values: None, pos, False. The value of False means that
the node is not yet done and that further checks need to be
performed. ]]>
                    </doc>
                </function>
                <function name="is_element">
                    <argspec varargs="None" keywords="None">
                        <args>
                            <arg name="self"/>
                            <arg name="parser"/>
                        </args>
                    </argspec>
                    <doc>
                        <![CDATA[Check to see if the parser's caret is positioned in an
element and return the index where the opening tag ends and
the number 1 (if element starts with '<') or 3 (if it starts
with '%%{'). ]]>
                    </doc>
                </function>
                <function name="is_empty">
                    <argspec varargs="None" keywords="None">
                        <args>
                            <arg name="self"/>
                            <arg name="parser"/>
                            <arg name="index"/>
                            <arg name="end"/>
                            <arg name="tagname"/>
                        </args>
                    </argspec>
                    <doc>
                        <![CDATA[Checks to see if the parser has reached '/'. ]]>
                    </doc>
                </function>
                <function name="make_node">
                    <argspec varargs="None" keywords="None">
                        <args>
                            <arg name="self"/>
                        </args>
                    </argspec>
                    <doc>
                        <![CDATA[Returns an `Element` node. ]]>
                    </doc>
                </function>
                <function name="prop_shortcut">
                    <argspec varargs="None" keywords="None">
                        <args>
                            <arg name="self"/>
                            <arg name="parser"/>
                            <arg name="node"/>
                            <arg name="prop"/>
                            <arg name="prop_index"/>
                        </args>
                    </argspec>
                    <doc>
                        <![CDATA[Instead of having an implied attribute we may have one of
the following shortcuts:

    #idname .class1 [attref1] @ref

The first sets the attribute id to idname. If the implied
value starts with a period (dot) then that value gets
appended to the attribute class. If the values are within
square brackets then the content of the brackets gets
appended to an attribute called _alref. The valid If the
value starts with @ then its value will be stored in an
attribute called _pyref. Notice that the value cannot be
empty.

There are two extra shortcuts which are derived from # and @.
The following are equivalent: #id-ref-name@ and
@id-ref-name#. The first expression says that the id should
be "id-ref-name" and that the same name should be used for
python to store the reference. The second one says to use
"id-ref-name" for python to store the reference and to use
the same name as the id. ]]>
                    </doc>
                </function>
                <function name="read_attributes">
                    <argspec varargs="None" keywords="None">
                        <args>
                            <arg name="self"/>
                            <arg name="parser"/>
                            <arg name="node"/>
                            <arg name="end"/>
                            <arg name="skip" default="1"/>
                        </args>
                    </argspec>
                    <doc>
                        <![CDATA[Parses the string

    parser.text[parser.caret:end]

and writes the information in node.

    att1="val1" att2="val2" ...

This function returns True if the opening tag ends with `/`.]]>
                    </doc>
                </function>
                <function name="read_prop">
                    <argspec varargs="None" keywords="None">
                        <args>
                            <arg name="self"/>
                            <arg name="parser"/>
                            <arg name="node"/>
                            <arg name="end"/>
                            <arg name="attlen"/>
                        </args>
                    </argspec>
                    <doc>
                        <![CDATA[Return [prop, prop_index, implied, empty]. ]]>
                    </doc>
                </function>
                <function name="read_val">
                    <argspec varargs="None" keywords="None">
                        <args>
                            <arg name="self"/>
                            <arg name="parser"/>
                            <arg name="end"/>
                            <arg name="tagname"/>
                        </args>
                    </argspec>
                    <doc>
                        <![CDATA[Returns the attribute value. ]]>
                    </doc>
                </function>
            </method_block>
            <method_block from="lexor.core.parser.NodeParser">
                <function name="__init__">
                    <argspec varargs="None" keywords="None">
                        <args>
                            <arg name="self"/>
                            <arg name="parser"/>
                        </args>
                    </argspec>
                    <doc>
                        <![CDATA[A |NodeParser| needs to be initialized with a |Parser|
object. If this method is to be overloaded then make sure
that it only accepts one parameter: ``parser``. This method
is used by |Parser| and it calls it with itself as the
parameter.]]>
                    </doc>
                </function>
                <function name="close">
                    <argspec varargs="None" keywords="None">
                        <args>
                            <arg name="self"/>
                            <arg name="node"/>
                        </args>
                    </argspec>
                    <doc>
                        <![CDATA[Returns the position where the element was closed. ]]>
                    </doc>
                </function>
                <function name="make_node">
                    <argspec varargs="None" keywords="None">
                        <args>
                            <arg name="self"/>
                        </args>
                    </argspec>
                    <doc>
                        <![CDATA[Returns an `Element` node. ]]>
                    </doc>
                </function>
                <function name="msg">
                    <argspec varargs="None" keywords="None">
                        <args>
                            <arg name="self"/>
                            <arg name="code"/>
                            <arg name="pos"/>
                            <arg name="arg" default="None"/>
                            <arg name="uri" default="None"/>
                        </args>
                    </argspec>
                    <doc>
                        <![CDATA[Send a message to the parser by providing one of the error
codes defined in the style as well as the position where the
error took place. The position has the form of a list
containing the line and column number. Some error codes may
provide arguments, this can be passed to `arg`. In case the
error occurred somewhere not in the current document, perhaps
in a string, then you may provide a new `uri` to denote the
location.]]>
                    </doc>
                </function>
            </method_block>
            <member_block from="lexor.core.parser.NodeParser">
                <member name="__weakref__"/>
            </member_block>
            <method_block from="__builtin__.object">
                <function name="__init__">
                    <argspec varargs="None" keywords="None">
                        <args>
                            <arg name="self"/>
                            <arg name="parser"/>
                        </args>
                    </argspec>
                    <doc>
                        <![CDATA[A |NodeParser| needs to be initialized with a |Parser|
object. If this method is to be overloaded then make sure
that it only accepts one parameter: ``parser``. This method
is used by |Parser| and it calls it with itself as the
parameter.]]>
                    </doc>
                </function>
            </method_block>
        </class>
    </classes>
    <functions/>
    <data>
        <data name="RAWTEXT_ELEMENT">
            <![CDATA[('script', 'style', 'textarea', 'title', 'undef', 'usepackage')]]>
        </data>
        <data name="AUTO_CLOSE">
            <![CDATA[{'a': ['a'], 'p': ['address', 'article', 'aside', 'blockquote', 'dir', 'div', 'dl', 'fieldset', 'footer', 'form', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'header', 'hgroup', 'hr', 'main', 'menu', 'nav', 'ol', 'p', 'pre', 'section', 'table', 'ul']}]]>
        </data>
        <data name="RE_NOSPACE">
            <![CDATA[<_sre.SRE_Pattern object at 0x1065ebb58>]]>
        </data>
        <data name="RE_NEXT">
            <![CDATA[<_sre.SRE_Pattern object at 0x10669b0e8>]]>
        </data>
        <data name="END_CHAR">
            <![CDATA[{1: '>', 3: '}', '<': '>', '%%{': '}'}]]>
        </data>
        <data name="MSG_EXPLANATION">
            <![CDATA[['\n    - The opening tag of an element cannot contain `<`. This means\n      that attributes cannot contain `<` in them.\n\n    Okay: <apple att1="val1"></apple>\n\n    E100: <apple att1="a < b"></apple>\n', '\n    - `RawText` elements are terminated when the appropriate closing\n      tag is found. Make sure to provide its proper closing tag.\n\n    Okay: <title>My awesome website</title>\n    Okay: %%{title}My awesome website%%\n    Okay: <script>a < b && b > c</script>\n    Okay: %%{script}a < b && b > c%%\n\n    E110: <title>My not so great website</title >\n    E110: <title>My not so great website< / title >\n    E110: <title>My not so great website\n    E110: <script>a < b && b > c\n    E110: %%{script}a < b && b > c%\n    E110: %%{script}a < b && b > c\n', '\n    - A `Void` Element\'s opening tag must end with `/>`. Anything in\n      between the characters `/` and `>` will be ignored.\n\n    - Non-void elements whose opening tag start with `/>` will be\n      also be interpreted correctly a message will be issued.\n\n    Okay:\n        <img href="/path/to/image.png"/>\n\n    Okay: <p>starting a new paragraph</p>\n\n    E120: <img href="/path/to/image.png"/  >\n    E121: <p />starting a new paragraph</p>\n', '\n    - Attributes need to be separated by one space.\n\n    - Do not repeat attributes since the values will only get\n      overwritten.\n\n    Okay: <tag att1="val1" att2="val2">content</tag>\n    Okay: <tag att1=\'1\' att2=\'2\'></tag>\n\n    E130: <tag att1="val1"att2="val2">content</tag>\n    E160: <tag att1=\'1\' att1=\'2\'></tag>\n', '\n    A few attributes rules:\n\n    - There is a risk of joining attributes together when using\n      unquoted attribute values. This may result in having a quote or\n      equal sign inside the unquoted attribute value. [E140]\n\n    - If your attribute contains `/` then the attribute should be\n      quoted. [E141]\n\n    - Quoted attributes need to be finished by its starting quotation\n      character. [E150]\n\n    Okay: <tag att1=val1 att2="val2">content</tag>\n    E140: <tag att1=val1att2="val2">content</tag>\n    Okay: <tag @idname .class1 .class2 [attref1] @ref>content</tag>\n\n    Okay:\n        %%{img href="path/to/image.png"}\n\n    E141:\n        <img href=path/to/image.png />\n\n    Okay: <tag att1="num"></tag>\n    Okay: <tag att1=\'num\'></tag>\n\n    E150: <tag att1="num\'></tag>\n    E150: <tag att1="num></tag>\n    E150: <tag att1=\'num"></tag>\n    E150: <tag att1=\'num></tag>\n', '\n    - The id attribute need to begin with a letter ([A-Za-z]) and may\n      be followed by any number of letters, digits ([0-9]), hyphens\n      (`-`), underscores (`_`), colons (`:`), and periods (`.`).\n\n    - The `@` symbol is reserved to tell python that you wish to\n      keep a reference to that particular element.\n\n    Okay: %%{h1 #section-1}Section 1%%\n    Okay: <h2 #section-2 @sec2>Section 2</h2>\n    Okay: %%{h3 #sec3@}Section 3%%\n\n    E170: %%{h1 #}Section 1%%\n    E170: <h2 #section-2 @>Section 2</h2>\n    E170: %%{h1 id}Section 1%%\n    E171: %%{h3 #@}Section 3%%\n']]]>
        </data>
        <data name="VOID_ELEMENT">
            <![CDATA[('area', 'base', 'basefont', 'br', 'col', 'frame', 'hr', 'img', 'input', 'isindex', 'link', 'meta', 'param', 'command', 'embed', 'keygen', 'source', 'track', 'wbr', 'include', 'documentclass', 'bibliography')]]>
        </data>
        <data name="MSG">
            <![CDATA[{'E160': 'attribute name "{0}" has already been declared', 'E171': 'python references and element ids cannot be empty', 'E170': '{0} cannot be empty', 'E110': '`RawText` {0}{1} closing tag `{2}` not found', 'E150': 'assuming quoted attribute to close at {0}:{1:2}', 'E140': '`{0}` found in unquoted attribute value', 'E141': '`/` found in unquoted attribute value', 'E100': 'element discarded due to `<` at {0}:{1:2}', 'E120': '`/` not immediately followed by `>`', 'E121': 'self-closing syntax (`/>`) used in non-void element', 'E130': 'no space between attributes'}]]>
        </data>
        <data name="AUTO_CLOSE_FIRST">
            <![CDATA[{'option': ['optgroup', 'option'], 'dd': ['dt', 'dd'], 'optgroup': ['optgroup'], 'dt': ['dt', 'dd'], 'rt': ['rt', 'rp'], 'rp': ['rt', 'rp'], 'tr': ['tr'], 'tbody': ['tbody', 'tfoot'], 'li': ['li'], 'tfoot': ['tbody'], 'th': ['td', 'th'], 'td': ['td', 'th'], 'thead': ['tbody', 'tfoot']}]]>
        </data>
        <data name="RE">
            <![CDATA[<_sre.SRE_Pattern object at 0x10631ff48>]]>
        </data>
    </data>
    <imports>
        <module fullname="re" name="re"/>
        <other fullname="lexor.core.elements.RawText" type="type" name="RawText"/>
        <other fullname="lexor.core.elements.Element" type="type" name="Element"/>
        <other fullname="lexor.core.elements.Void" type="type" name="Void"/>
        <other fullname="lexor.core.parser.NodeParser" type="type" name="NodeParser"/>
    </imports>
</module>
<module name="lexor-lang_lexor_parser_default_latex">
    <doc>
        <![CDATA[LEXOR: LATEX NodeParser

Processes LaTeX elements.

]]>
    </doc>
    <classes>
        <class name="LatexInlineNP">
            <bases>
                <base name="lexor.core.parser.NodeParser"/>
            </bases>
            <mro>
                <class name="lexor-lang_lexor_parser_default_latex.LatexInlineNP"/>
                <class name="lexor.core.parser.NodeParser"/>
                <class name="__builtin__.object"/>
            </mro>
            <doc>
                <![CDATA[Parse text enclosed by $, \(. ]]>
            </doc>
            <method_block from="lexor-lang_lexor_parser_default_latex.LatexInlineNP">
                <function name="make_node">
                    <argspec varargs="None" keywords="None">
                        <args>
                            <arg name="self"/>
                        </args>
                    </argspec>
                </function>
            </method_block>
            <method_block from="lexor.core.parser.NodeParser">
                <function name="__init__">
                    <argspec varargs="None" keywords="None">
                        <args>
                            <arg name="self"/>
                            <arg name="parser"/>
                        </args>
                    </argspec>
                    <doc>
                        <![CDATA[A |NodeParser| needs to be initialized with a |Parser|
object. If this method is to be overloaded then make sure
that it only accepts one parameter: ``parser``. This method
is used by |Parser| and it calls it with itself as the
parameter.]]>
                    </doc>
                </function>
                <function name="close">
                    <argspec varargs="None" keywords="None">
                        <args>
                            <arg name="self"/>
                            <arg name="_"/>
                        </args>
                    </argspec>
                    <doc>
                        <![CDATA[This method needs to be overloaded if the node parser
returns a |Node| with the :meth:`make_node` method.

This method will not get called if :meth:`make_node` returned
a |Node| inside a ``list``. The close function takes as input
the node object that :meth:`make_node` returned and it should
decide if the node can be closed or not. If it is indeed time
to close the node then return a ``list`` with the position
where the node is being closed, otherwise return ``None``.

If this method is not overloaded then a
``NotImplementedError`` exception will be raised.]]>
                    </doc>
                </function>
                <function name="make_node">
                    <argspec varargs="None" keywords="None">
                        <args>
                            <arg name="self"/>
                        </args>
                    </argspec>
                </function>
                <function name="msg">
                    <argspec varargs="None" keywords="None">
                        <args>
                            <arg name="self"/>
                            <arg name="code"/>
                            <arg name="pos"/>
                            <arg name="arg" default="None"/>
                            <arg name="uri" default="None"/>
                        </args>
                    </argspec>
                    <doc>
                        <![CDATA[Send a message to the parser by providing one of the error
codes defined in the style as well as the position where the
error took place. The position has the form of a list
containing the line and column number. Some error codes may
provide arguments, this can be passed to `arg`. In case the
error occurred somewhere not in the current document, perhaps
in a string, then you may provide a new `uri` to denote the
location.]]>
                    </doc>
                </function>
            </method_block>
            <member_block from="lexor.core.parser.NodeParser">
                <member name="__weakref__"/>
            </member_block>
            <method_block from="__builtin__.object">
                <function name="__init__">
                    <argspec varargs="None" keywords="None">
                        <args>
                            <arg name="self"/>
                            <arg name="parser"/>
                        </args>
                    </argspec>
                    <doc>
                        <![CDATA[A |NodeParser| needs to be initialized with a |Parser|
object. If this method is to be overloaded then make sure
that it only accepts one parameter: ``parser``. This method
is used by |Parser| and it calls it with itself as the
parameter.]]>
                    </doc>
                </function>
            </method_block>
        </class>
        <class name="LatexDisplayNP">
            <bases>
                <base name="lexor.core.parser.NodeParser"/>
            </bases>
            <mro>
                <class name="lexor-lang_lexor_parser_default_latex.LatexDisplayNP"/>
                <class name="lexor.core.parser.NodeParser"/>
                <class name="__builtin__.object"/>
            </mro>
            <doc>
                <![CDATA[Parse text enclosed by $$, \[. ]]>
            </doc>
            <method_block from="lexor-lang_lexor_parser_default_latex.LatexDisplayNP">
                <function name="make_node">
                    <argspec varargs="None" keywords="None">
                        <args>
                            <arg name="self"/>
                        </args>
                    </argspec>
                </function>
            </method_block>
            <method_block from="lexor.core.parser.NodeParser">
                <function name="__init__">
                    <argspec varargs="None" keywords="None">
                        <args>
                            <arg name="self"/>
                            <arg name="parser"/>
                        </args>
                    </argspec>
                    <doc>
                        <![CDATA[A |NodeParser| needs to be initialized with a |Parser|
object. If this method is to be overloaded then make sure
that it only accepts one parameter: ``parser``. This method
is used by |Parser| and it calls it with itself as the
parameter.]]>
                    </doc>
                </function>
                <function name="close">
                    <argspec varargs="None" keywords="None">
                        <args>
                            <arg name="self"/>
                            <arg name="_"/>
                        </args>
                    </argspec>
                    <doc>
                        <![CDATA[This method needs to be overloaded if the node parser
returns a |Node| with the :meth:`make_node` method.

This method will not get called if :meth:`make_node` returned
a |Node| inside a ``list``. The close function takes as input
the node object that :meth:`make_node` returned and it should
decide if the node can be closed or not. If it is indeed time
to close the node then return a ``list`` with the position
where the node is being closed, otherwise return ``None``.

If this method is not overloaded then a
``NotImplementedError`` exception will be raised.]]>
                    </doc>
                </function>
                <function name="make_node">
                    <argspec varargs="None" keywords="None">
                        <args>
                            <arg name="self"/>
                        </args>
                    </argspec>
                </function>
                <function name="msg">
                    <argspec varargs="None" keywords="None">
                        <args>
                            <arg name="self"/>
                            <arg name="code"/>
                            <arg name="pos"/>
                            <arg name="arg" default="None"/>
                            <arg name="uri" default="None"/>
                        </args>
                    </argspec>
                    <doc>
                        <![CDATA[Send a message to the parser by providing one of the error
codes defined in the style as well as the position where the
error took place. The position has the form of a list
containing the line and column number. Some error codes may
provide arguments, this can be passed to `arg`. In case the
error occurred somewhere not in the current document, perhaps
in a string, then you may provide a new `uri` to denote the
location.]]>
                    </doc>
                </function>
            </method_block>
            <member_block from="lexor.core.parser.NodeParser">
                <member name="__weakref__"/>
            </member_block>
            <method_block from="__builtin__.object">
                <function name="__init__">
                    <argspec varargs="None" keywords="None">
                        <args>
                            <arg name="self"/>
                            <arg name="parser"/>
                        </args>
                    </argspec>
                    <doc>
                        <![CDATA[A |NodeParser| needs to be initialized with a |Parser|
object. If this method is to be overloaded then make sure
that it only accepts one parameter: ``parser``. This method
is used by |Parser| and it calls it with itself as the
parameter.]]>
                    </doc>
                </function>
            </method_block>
        </class>
    </classes>
    <functions/>
    <data>
        <data name="MAP">
            <![CDATA[{'$$': '$$', '$': '$', '\\(': '\\)', '\\[': '\\]'}]]>
        </data>
        <data name="MSG">
            <![CDATA[{'E100': 'unfinished display LaTeX enviroment'}]]>
        </data>
        <data name="MSG_EXPLANATION">
            <![CDATA[['\n    - Display LaTeX enviroment start with `$$` or `\\[` and end with\n      `$$` or `\\]`. If you wish to display them then consider\n      escaping them, i.e. `\\$\\$`.\n\n    Okay:\n        $$\\sum$$\n\n    E100:\n        $$\\sum\n']]]>
        </data>
        <data name="EMPTY">
            <![CDATA[' \t\n\r\x0c\x0b']]>
        </data>
    </data>
    <imports>
        <other fullname="lexor.core.elements.RawText" type="type" name="RawText"/>
        <other fullname="lexor.core.parser.NodeParser" type="type" name="NodeParser"/>
        <other fullname="lexor.core.elements.Entity" type="type" name="Entity"/>
    </imports>
</module>
<module name="lexor-lang_lexor_parser_default_inline">
    <doc>
        <![CDATA[LEXOR: INLINE NodeParsers

Here we define several parsers for inline patterns.

]]>
    </doc>
    <classes>
        <class name="StrongEmNP">
            <bases>
                <base name="lexor-lang_lexor_parser_default_inline.InlinePatternNP"/>
            </bases>
            <mro>
                <class name="lexor-lang_lexor_parser_default_inline.StrongEmNP"/>
                <class name="lexor-lang_lexor_parser_default_inline.InlinePatternNP"/>
                <class name="lexor.core.parser.NodeParser"/>
                <class name="__builtin__.object"/>
            </mro>
            <doc>
                <![CDATA[Checks for triple `*`. ]]>
            </doc>
            <method_block from="lexor-lang_lexor_parser_default_inline.StrongEmNP">
                <function name="__init__">
                    <argspec varargs="None" keywords="None">
                        <args>
                            <arg name="self"/>
                            <arg name="parser"/>
                        </args>
                    </argspec>
                </function>
            </method_block>
            <method_block from="lexor-lang_lexor_parser_default_inline.InlinePatternNP">
                <function name="__init__">
                    <argspec varargs="None" keywords="None">
                        <args>
                            <arg name="self"/>
                            <arg name="parser"/>
                        </args>
                    </argspec>
                </function>
                <function name="close">
                    <argspec varargs="None" keywords="None">
                        <args>
                            <arg name="self"/>
                            <arg name="node"/>
                        </args>
                    </argspec>
                </function>
                <function name="make_node">
                    <argspec varargs="None" keywords="None">
                        <args>
                            <arg name="self"/>
                        </args>
                    </argspec>
                </function>
            </method_block>
            <method_block from="lexor.core.parser.NodeParser">
                <function name="__init__">
                    <argspec varargs="None" keywords="None">
                        <args>
                            <arg name="self"/>
                            <arg name="parser"/>
                        </args>
                    </argspec>
                </function>
                <function name="close">
                    <argspec varargs="None" keywords="None">
                        <args>
                            <arg name="self"/>
                            <arg name="node"/>
                        </args>
                    </argspec>
                </function>
                <function name="make_node">
                    <argspec varargs="None" keywords="None">
                        <args>
                            <arg name="self"/>
                        </args>
                    </argspec>
                </function>
                <function name="msg">
                    <argspec varargs="None" keywords="None">
                        <args>
                            <arg name="self"/>
                            <arg name="code"/>
                            <arg name="pos"/>
                            <arg name="arg" default="None"/>
                            <arg name="uri" default="None"/>
                        </args>
                    </argspec>
                    <doc>
                        <![CDATA[Send a message to the parser by providing one of the error
codes defined in the style as well as the position where the
error took place. The position has the form of a list
containing the line and column number. Some error codes may
provide arguments, this can be passed to `arg`. In case the
error occurred somewhere not in the current document, perhaps
in a string, then you may provide a new `uri` to denote the
location.]]>
                    </doc>
                </function>
            </method_block>
            <member_block from="lexor.core.parser.NodeParser">
                <member name="__weakref__"/>
            </member_block>
            <method_block from="__builtin__.object">
                <function name="__init__">
                    <argspec varargs="None" keywords="None">
                        <args>
                            <arg name="self"/>
                            <arg name="parser"/>
                        </args>
                    </argspec>
                </function>
            </method_block>
        </class>
        <class name="EmNP">
            <bases>
                <base name="lexor-lang_lexor_parser_default_inline.InlinePatternNP"/>
            </bases>
            <mro>
                <class name="lexor-lang_lexor_parser_default_inline.EmNP"/>
                <class name="lexor-lang_lexor_parser_default_inline.InlinePatternNP"/>
                <class name="lexor.core.parser.NodeParser"/>
                <class name="__builtin__.object"/>
            </mro>
            <doc>
                <![CDATA[Parser text located between '*' and '*'. ]]>
            </doc>
            <method_block from="lexor-lang_lexor_parser_default_inline.EmNP">
                <function name="__init__">
                    <argspec varargs="None" keywords="None">
                        <args>
                            <arg name="self"/>
                            <arg name="parser"/>
                        </args>
                    </argspec>
                </function>
            </method_block>
            <method_block from="lexor-lang_lexor_parser_default_inline.InlinePatternNP">
                <function name="__init__">
                    <argspec varargs="None" keywords="None">
                        <args>
                            <arg name="self"/>
                            <arg name="parser"/>
                        </args>
                    </argspec>
                </function>
                <function name="close">
                    <argspec varargs="None" keywords="None">
                        <args>
                            <arg name="self"/>
                            <arg name="node"/>
                        </args>
                    </argspec>
                </function>
                <function name="make_node">
                    <argspec varargs="None" keywords="None">
                        <args>
                            <arg name="self"/>
                        </args>
                    </argspec>
                </function>
            </method_block>
            <method_block from="lexor.core.parser.NodeParser">
                <function name="__init__">
                    <argspec varargs="None" keywords="None">
                        <args>
                            <arg name="self"/>
                            <arg name="parser"/>
                        </args>
                    </argspec>
                </function>
                <function name="close">
                    <argspec varargs="None" keywords="None">
                        <args>
                            <arg name="self"/>
                            <arg name="node"/>
                        </args>
                    </argspec>
                </function>
                <function name="make_node">
                    <argspec varargs="None" keywords="None">
                        <args>
                            <arg name="self"/>
                        </args>
                    </argspec>
                </function>
                <function name="msg">
                    <argspec varargs="None" keywords="None">
                        <args>
                            <arg name="self"/>
                            <arg name="code"/>
                            <arg name="pos"/>
                            <arg name="arg" default="None"/>
                            <arg name="uri" default="None"/>
                        </args>
                    </argspec>
                    <doc>
                        <![CDATA[Send a message to the parser by providing one of the error
codes defined in the style as well as the position where the
error took place. The position has the form of a list
containing the line and column number. Some error codes may
provide arguments, this can be passed to `arg`. In case the
error occurred somewhere not in the current document, perhaps
in a string, then you may provide a new `uri` to denote the
location.]]>
                    </doc>
                </function>
            </method_block>
            <member_block from="lexor.core.parser.NodeParser">
                <member name="__weakref__"/>
            </member_block>
            <method_block from="__builtin__.object">
                <function name="__init__">
                    <argspec varargs="None" keywords="None">
                        <args>
                            <arg name="self"/>
                            <arg name="parser"/>
                        </args>
                    </argspec>
                </function>
            </method_block>
        </class>
        <class name="SmartEmNP">
            <bases>
                <base name="lexor.core.parser.NodeParser"/>
            </bases>
            <mro>
                <class name="lexor-lang_lexor_parser_default_inline.SmartEmNP"/>
                <class name="lexor.core.parser.NodeParser"/>
                <class name="__builtin__.object"/>
            </mro>
            <doc>
                <![CDATA[Checks for _em_. ]]>
            </doc>
            <method_block from="lexor-lang_lexor_parser_default_inline.SmartEmNP">
                <function name="close">
                    <argspec varargs="None" keywords="None">
                        <args>
                            <arg name="self"/>
                            <arg name="node"/>
                        </args>
                    </argspec>
                </function>
                <function name="make_node">
                    <argspec varargs="None" keywords="None">
                        <args>
                            <arg name="self"/>
                        </args>
                    </argspec>
                </function>
            </method_block>
            <method_block from="lexor.core.parser.NodeParser">
                <function name="__init__">
                    <argspec varargs="None" keywords="None">
                        <args>
                            <arg name="self"/>
                            <arg name="parser"/>
                        </args>
                    </argspec>
                    <doc>
                        <![CDATA[A |NodeParser| needs to be initialized with a |Parser|
object. If this method is to be overloaded then make sure
that it only accepts one parameter: ``parser``. This method
is used by |Parser| and it calls it with itself as the
parameter.]]>
                    </doc>
                </function>
                <function name="close">
                    <argspec varargs="None" keywords="None">
                        <args>
                            <arg name="self"/>
                            <arg name="node"/>
                        </args>
                    </argspec>
                </function>
                <function name="make_node">
                    <argspec varargs="None" keywords="None">
                        <args>
                            <arg name="self"/>
                        </args>
                    </argspec>
                </function>
                <function name="msg">
                    <argspec varargs="None" keywords="None">
                        <args>
                            <arg name="self"/>
                            <arg name="code"/>
                            <arg name="pos"/>
                            <arg name="arg" default="None"/>
                            <arg name="uri" default="None"/>
                        </args>
                    </argspec>
                    <doc>
                        <![CDATA[Send a message to the parser by providing one of the error
codes defined in the style as well as the position where the
error took place. The position has the form of a list
containing the line and column number. Some error codes may
provide arguments, this can be passed to `arg`. In case the
error occurred somewhere not in the current document, perhaps
in a string, then you may provide a new `uri` to denote the
location.]]>
                    </doc>
                </function>
            </method_block>
            <member_block from="lexor.core.parser.NodeParser">
                <member name="__weakref__"/>
            </member_block>
            <method_block from="__builtin__.object">
                <function name="__init__">
                    <argspec varargs="None" keywords="None">
                        <args>
                            <arg name="self"/>
                            <arg name="parser"/>
                        </args>
                    </argspec>
                    <doc>
                        <![CDATA[A |NodeParser| needs to be initialized with a |Parser|
object. If this method is to be overloaded then make sure
that it only accepts one parameter: ``parser``. This method
is used by |Parser| and it calls it with itself as the
parameter.]]>
                    </doc>
                </function>
            </method_block>
        </class>
        <class name="EmStrongNP">
            <bases>
                <base name="lexor-lang_lexor_parser_default_inline.InlinePatternNP"/>
            </bases>
            <mro>
                <class name="lexor-lang_lexor_parser_default_inline.EmStrongNP"/>
                <class name="lexor-lang_lexor_parser_default_inline.InlinePatternNP"/>
                <class name="lexor.core.parser.NodeParser"/>
                <class name="__builtin__.object"/>
            </mro>
            <doc>
                <![CDATA[Checks for triple `_`. ]]>
            </doc>
            <method_block from="lexor-lang_lexor_parser_default_inline.EmStrongNP">
                <function name="__init__">
                    <argspec varargs="None" keywords="None">
                        <args>
                            <arg name="self"/>
                            <arg name="parser"/>
                        </args>
                    </argspec>
                </function>
            </method_block>
            <method_block from="lexor-lang_lexor_parser_default_inline.InlinePatternNP">
                <function name="__init__">
                    <argspec varargs="None" keywords="None">
                        <args>
                            <arg name="self"/>
                            <arg name="parser"/>
                        </args>
                    </argspec>
                </function>
                <function name="close">
                    <argspec varargs="None" keywords="None">
                        <args>
                            <arg name="self"/>
                            <arg name="node"/>
                        </args>
                    </argspec>
                </function>
                <function name="make_node">
                    <argspec varargs="None" keywords="None">
                        <args>
                            <arg name="self"/>
                        </args>
                    </argspec>
                </function>
            </method_block>
            <method_block from="lexor.core.parser.NodeParser">
                <function name="__init__">
                    <argspec varargs="None" keywords="None">
                        <args>
                            <arg name="self"/>
                            <arg name="parser"/>
                        </args>
                    </argspec>
                </function>
                <function name="close">
                    <argspec varargs="None" keywords="None">
                        <args>
                            <arg name="self"/>
                            <arg name="node"/>
                        </args>
                    </argspec>
                </function>
                <function name="make_node">
                    <argspec varargs="None" keywords="None">
                        <args>
                            <arg name="self"/>
                        </args>
                    </argspec>
                </function>
                <function name="msg">
                    <argspec varargs="None" keywords="None">
                        <args>
                            <arg name="self"/>
                            <arg name="code"/>
                            <arg name="pos"/>
                            <arg name="arg" default="None"/>
                            <arg name="uri" default="None"/>
                        </args>
                    </argspec>
                    <doc>
                        <![CDATA[Send a message to the parser by providing one of the error
codes defined in the style as well as the position where the
error took place. The position has the form of a list
containing the line and column number. Some error codes may
provide arguments, this can be passed to `arg`. In case the
error occurred somewhere not in the current document, perhaps
in a string, then you may provide a new `uri` to denote the
location.]]>
                    </doc>
                </function>
            </method_block>
            <member_block from="lexor.core.parser.NodeParser">
                <member name="__weakref__"/>
            </member_block>
            <method_block from="__builtin__.object">
                <function name="__init__">
                    <argspec varargs="None" keywords="None">
                        <args>
                            <arg name="self"/>
                            <arg name="parser"/>
                        </args>
                    </argspec>
                </function>
            </method_block>
        </class>
        <class name="InlinePatternNP">
            <bases>
                <base name="lexor.core.parser.NodeParser"/>
            </bases>
            <mro>
                <class name="lexor-lang_lexor_parser_default_inline.InlinePatternNP"/>
                <class name="lexor.core.parser.NodeParser"/>
                <class name="__builtin__.object"/>
            </mro>
            <doc>
                <![CDATA[Abstract class for a few inline patterns. ]]>
            </doc>
            <method_block from="lexor-lang_lexor_parser_default_inline.InlinePatternNP">
                <function name="__init__">
                    <argspec varargs="None" keywords="None">
                        <args>
                            <arg name="self"/>
                            <arg name="parser"/>
                        </args>
                    </argspec>
                    <doc>
                        <![CDATA[To be able to use the this class you need to derive a node
parser from this abstract class. You only need to overload
this method and define the following:

    self.parser = parser
    self.pattern = None
    self.tight = True  # No separation <pattern>text<pattern>
    self.tagname = None

For instance: ("**", True, "strong") will transform

    `**strong**` into <strong>strong</strong>

but not `**strong **`.]]>
                    </doc>
                </function>
                <function name="close">
                    <argspec varargs="None" keywords="None">
                        <args>
                            <arg name="self"/>
                            <arg name="node"/>
                        </args>
                    </argspec>
                </function>
                <function name="make_node">
                    <argspec varargs="None" keywords="None">
                        <args>
                            <arg name="self"/>
                        </args>
                    </argspec>
                </function>
            </method_block>
            <method_block from="lexor.core.parser.NodeParser">
                <function name="__init__">
                    <argspec varargs="None" keywords="None">
                        <args>
                            <arg name="self"/>
                            <arg name="parser"/>
                        </args>
                    </argspec>
                    <doc>
                        <![CDATA[To be able to use the this class you need to derive a node
parser from this abstract class. You only need to overload
this method and define the following:

    self.parser = parser
    self.pattern = None
    self.tight = True  # No separation <pattern>text<pattern>
    self.tagname = None

For instance: ("**", True, "strong") will transform

    `**strong**` into <strong>strong</strong>

but not `**strong **`.]]>
                    </doc>
                </function>
                <function name="close">
                    <argspec varargs="None" keywords="None">
                        <args>
                            <arg name="self"/>
                            <arg name="node"/>
                        </args>
                    </argspec>
                </function>
                <function name="make_node">
                    <argspec varargs="None" keywords="None">
                        <args>
                            <arg name="self"/>
                        </args>
                    </argspec>
                </function>
                <function name="msg">
                    <argspec varargs="None" keywords="None">
                        <args>
                            <arg name="self"/>
                            <arg name="code"/>
                            <arg name="pos"/>
                            <arg name="arg" default="None"/>
                            <arg name="uri" default="None"/>
                        </args>
                    </argspec>
                    <doc>
                        <![CDATA[Send a message to the parser by providing one of the error
codes defined in the style as well as the position where the
error took place. The position has the form of a list
containing the line and column number. Some error codes may
provide arguments, this can be passed to `arg`. In case the
error occurred somewhere not in the current document, perhaps
in a string, then you may provide a new `uri` to denote the
location.]]>
                    </doc>
                </function>
            </method_block>
            <member_block from="lexor.core.parser.NodeParser">
                <member name="__weakref__"/>
            </member_block>
            <method_block from="__builtin__.object">
                <function name="__init__">
                    <argspec varargs="None" keywords="None">
                        <args>
                            <arg name="self"/>
                            <arg name="parser"/>
                        </args>
                    </argspec>
                    <doc>
                        <![CDATA[To be able to use the this class you need to derive a node
parser from this abstract class. You only need to overload
this method and define the following:

    self.parser = parser
    self.pattern = None
    self.tight = True  # No separation <pattern>text<pattern>
    self.tagname = None

For instance: ("**", True, "strong") will transform

    `**strong**` into <strong>strong</strong>

but not `**strong **`.]]>
                    </doc>
                </function>
            </method_block>
        </class>
        <class name="StrongNP">
            <bases>
                <base name="lexor-lang_lexor_parser_default_inline.InlinePatternNP"/>
            </bases>
            <mro>
                <class name="lexor-lang_lexor_parser_default_inline.StrongNP"/>
                <class name="lexor-lang_lexor_parser_default_inline.InlinePatternNP"/>
                <class name="lexor.core.parser.NodeParser"/>
                <class name="__builtin__.object"/>
            </mro>
            <doc>
                <![CDATA[Parse text located between `**` and `**`. ]]>
            </doc>
            <method_block from="lexor-lang_lexor_parser_default_inline.StrongNP">
                <function name="__init__">
                    <argspec varargs="None" keywords="None">
                        <args>
                            <arg name="self"/>
                            <arg name="parser"/>
                        </args>
                    </argspec>
                </function>
            </method_block>
            <method_block from="lexor-lang_lexor_parser_default_inline.InlinePatternNP">
                <function name="__init__">
                    <argspec varargs="None" keywords="None">
                        <args>
                            <arg name="self"/>
                            <arg name="parser"/>
                        </args>
                    </argspec>
                </function>
                <function name="close">
                    <argspec varargs="None" keywords="None">
                        <args>
                            <arg name="self"/>
                            <arg name="node"/>
                        </args>
                    </argspec>
                </function>
                <function name="make_node">
                    <argspec varargs="None" keywords="None">
                        <args>
                            <arg name="self"/>
                        </args>
                    </argspec>
                </function>
            </method_block>
            <method_block from="lexor.core.parser.NodeParser">
                <function name="__init__">
                    <argspec varargs="None" keywords="None">
                        <args>
                            <arg name="self"/>
                            <arg name="parser"/>
                        </args>
                    </argspec>
                </function>
                <function name="close">
                    <argspec varargs="None" keywords="None">
                        <args>
                            <arg name="self"/>
                            <arg name="node"/>
                        </args>
                    </argspec>
                </function>
                <function name="make_node">
                    <argspec varargs="None" keywords="None">
                        <args>
                            <arg name="self"/>
                        </args>
                    </argspec>
                </function>
                <function name="msg">
                    <argspec varargs="None" keywords="None">
                        <args>
                            <arg name="self"/>
                            <arg name="code"/>
                            <arg name="pos"/>
                            <arg name="arg" default="None"/>
                            <arg name="uri" default="None"/>
                        </args>
                    </argspec>
                    <doc>
                        <![CDATA[Send a message to the parser by providing one of the error
codes defined in the style as well as the position where the
error took place. The position has the form of a list
containing the line and column number. Some error codes may
provide arguments, this can be passed to `arg`. In case the
error occurred somewhere not in the current document, perhaps
in a string, then you may provide a new `uri` to denote the
location.]]>
                    </doc>
                </function>
            </method_block>
            <member_block from="lexor.core.parser.NodeParser">
                <member name="__weakref__"/>
            </member_block>
            <method_block from="__builtin__.object">
                <function name="__init__">
                    <argspec varargs="None" keywords="None">
                        <args>
                            <arg name="self"/>
                            <arg name="parser"/>
                        </args>
                    </argspec>
                </function>
            </method_block>
        </class>
        <class name="Strong2NP">
            <bases>
                <base name="lexor-lang_lexor_parser_default_inline.InlinePatternNP"/>
            </bases>
            <mro>
                <class name="lexor-lang_lexor_parser_default_inline.Strong2NP"/>
                <class name="lexor-lang_lexor_parser_default_inline.InlinePatternNP"/>
                <class name="lexor.core.parser.NodeParser"/>
                <class name="__builtin__.object"/>
            </mro>
            <doc>
                <![CDATA[Parse text located between `__` and `__`. ]]>
            </doc>
            <method_block from="lexor-lang_lexor_parser_default_inline.Strong2NP">
                <function name="__init__">
                    <argspec varargs="None" keywords="None">
                        <args>
                            <arg name="self"/>
                            <arg name="parser"/>
                        </args>
                    </argspec>
                </function>
            </method_block>
            <method_block from="lexor-lang_lexor_parser_default_inline.InlinePatternNP">
                <function name="__init__">
                    <argspec varargs="None" keywords="None">
                        <args>
                            <arg name="self"/>
                            <arg name="parser"/>
                        </args>
                    </argspec>
                </function>
                <function name="close">
                    <argspec varargs="None" keywords="None">
                        <args>
                            <arg name="self"/>
                            <arg name="node"/>
                        </args>
                    </argspec>
                </function>
                <function name="make_node">
                    <argspec varargs="None" keywords="None">
                        <args>
                            <arg name="self"/>
                        </args>
                    </argspec>
                </function>
            </method_block>
            <method_block from="lexor.core.parser.NodeParser">
                <function name="__init__">
                    <argspec varargs="None" keywords="None">
                        <args>
                            <arg name="self"/>
                            <arg name="parser"/>
                        </args>
                    </argspec>
                </function>
                <function name="close">
                    <argspec varargs="None" keywords="None">
                        <args>
                            <arg name="self"/>
                            <arg name="node"/>
                        </args>
                    </argspec>
                </function>
                <function name="make_node">
                    <argspec varargs="None" keywords="None">
                        <args>
                            <arg name="self"/>
                        </args>
                    </argspec>
                </function>
                <function name="msg">
                    <argspec varargs="None" keywords="None">
                        <args>
                            <arg name="self"/>
                            <arg name="code"/>
                            <arg name="pos"/>
                            <arg name="arg" default="None"/>
                            <arg name="uri" default="None"/>
                        </args>
                    </argspec>
                    <doc>
                        <![CDATA[Send a message to the parser by providing one of the error
codes defined in the style as well as the position where the
error took place. The position has the form of a list
containing the line and column number. Some error codes may
provide arguments, this can be passed to `arg`. In case the
error occurred somewhere not in the current document, perhaps
in a string, then you may provide a new `uri` to denote the
location.]]>
                    </doc>
                </function>
            </method_block>
            <member_block from="lexor.core.parser.NodeParser">
                <member name="__weakref__"/>
            </member_block>
            <method_block from="__builtin__.object">
                <function name="__init__">
                    <argspec varargs="None" keywords="None">
                        <args>
                            <arg name="self"/>
                            <arg name="parser"/>
                        </args>
                    </argspec>
                </function>
            </method_block>
        </class>
    </classes>
    <functions/>
    <data>
        <data name="EMPTY">
            <![CDATA[' \t\n\r\x0c\x0b']]>
        </data>
    </data>
    <imports>
        <other fullname="lexor.core.elements.Element" type="type" name="Element"/>
        <other fullname="lexor.core.parser.NodeParser" type="type" name="NodeParser"/>
    </imports>
</module>
<module name="lexor-lang_lexor_parser_default_list">
    <doc>
        <![CDATA[LEXOR: LIST NodeParser

Parses list enviroments. To add attributes to the list
you may use square brackets and curly braces to add attributes
to the item list. For instance

    %%{list}
    +[#ol_id]{#first_item} Item 1
    +{#second_item} Item 2
    %%

Will be parsed to:

    list:
        list_item[level="1" type="ol" __id="ol_id" _id="first_item"]:
            p[remove="true"]:
                #text: 'Item 1'
        list_item[level="1" type="ol" _id="second_item"]:
            p[remove="true"]:
                #text: 'Item 2'

]]>
    </doc>
    <classes>
        <class name="ListNP">
            <bases>
                <base name="lexor.core.parser.NodeParser"/>
            </bases>
            <mro>
                <class name="lexor-lang_lexor_parser_default_list.ListNP"/>
                <class name="lexor.core.parser.NodeParser"/>
                <class name="__builtin__.object"/>
            </mro>
            <doc>
                <![CDATA[Look for list elements. ]]>
            </doc>
            <method_block from="lexor-lang_lexor_parser_default_list.ListNP">
                <function name="close">
                    <argspec varargs="None" keywords="None">
                        <args>
                            <arg name="self"/>
                            <arg name="node"/>
                        </args>
                    </argspec>
                </function>
                <function name="make_node">
                    <argspec varargs="None" keywords="None">
                        <args>
                            <arg name="self"/>
                        </args>
                    </argspec>
                </function>
            </method_block>
            <method_block from="lexor.core.parser.NodeParser">
                <function name="__init__">
                    <argspec varargs="None" keywords="None">
                        <args>
                            <arg name="self"/>
                            <arg name="parser"/>
                        </args>
                    </argspec>
                    <doc>
                        <![CDATA[A |NodeParser| needs to be initialized with a |Parser|
object. If this method is to be overloaded then make sure
that it only accepts one parameter: ``parser``. This method
is used by |Parser| and it calls it with itself as the
parameter.]]>
                    </doc>
                </function>
                <function name="close">
                    <argspec varargs="None" keywords="None">
                        <args>
                            <arg name="self"/>
                            <arg name="node"/>
                        </args>
                    </argspec>
                </function>
                <function name="make_node">
                    <argspec varargs="None" keywords="None">
                        <args>
                            <arg name="self"/>
                        </args>
                    </argspec>
                </function>
                <function name="msg">
                    <argspec varargs="None" keywords="None">
                        <args>
                            <arg name="self"/>
                            <arg name="code"/>
                            <arg name="pos"/>
                            <arg name="arg" default="None"/>
                            <arg name="uri" default="None"/>
                        </args>
                    </argspec>
                    <doc>
                        <![CDATA[Send a message to the parser by providing one of the error
codes defined in the style as well as the position where the
error took place. The position has the form of a list
containing the line and column number. Some error codes may
provide arguments, this can be passed to `arg`. In case the
error occurred somewhere not in the current document, perhaps
in a string, then you may provide a new `uri` to denote the
location.]]>
                    </doc>
                </function>
            </method_block>
            <member_block from="lexor.core.parser.NodeParser">
                <member name="__weakref__"/>
            </member_block>
            <method_block from="__builtin__.object">
                <function name="__init__">
                    <argspec varargs="None" keywords="None">
                        <args>
                            <arg name="self"/>
                            <arg name="parser"/>
                        </args>
                    </argspec>
                    <doc>
                        <![CDATA[A |NodeParser| needs to be initialized with a |Parser|
object. If this method is to be overloaded then make sure
that it only accepts one parameter: ``parser``. This method
is used by |Parser| and it calls it with itself as the
parameter.]]>
                    </doc>
                </function>
            </method_block>
        </class>
    </classes>
    <functions/>
    <imports>
        <other fullname="lexor.core.parser.NodeParser" type="type" name="NodeParser"/>
        <other fullname="lexor.core.elements.Element" type="type" name="Element"/>
    </imports>
</module>
